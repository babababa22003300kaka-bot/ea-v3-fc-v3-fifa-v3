#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸš€ Smart Telegram Sender Bot - Hybrid Adaptive Mode
Bot: @snipe12_bot

Architecture: Smart Cache with Burst Mode
- Central fetching with in-memory cache
- Local monitoring without network requests
- Temporary burst mode for new accounts
- Adaptive cache TTL based on activity
- Strict ID validation
"""

import asyncio
import json
import logging
import random
import re
from dataclasses import asdict, dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
from enum import Enum

import aiohttp
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Logging Configuration
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[
        logging.FileHandler("bot.log", encoding="utf-8"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ Load Configuration
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

with open("config.json", "r", encoding="utf-8") as f:
    CONFIG = json.load(f)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ Settings & State Management
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# CSRF Token caching
CSRF_TOKEN_TTL = 1200  # 20 minutes

# Cache Settings
BASE_CACHE_TTL = 300  # 5 minutes base TTL
MIN_CACHE_TTL = 120   # 2 minutes minimum
MAX_CACHE_TTL = 600   # 10 minutes maximum
BURST_MODE_DURATION = 60  # 60 seconds burst mode
BURST_REFRESH_INTERVAL = 2  # 2 seconds in burst mode

# Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ© (Transitional States)
TRANSITIONAL_STATUSES: Set[str] = {
    "LOGGING",
    "LOGGED", 
    "LOGGED IN",
    "CODE SENT",
    "WAITING",
}

# Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© (Final States)
FINAL_STATUSES: Set[str] = {
    "AVAILABLE",
    "ACTIVE",
    "WRONG DETAILS",
    "BACKUP CODE WRONG",
    "NEW ACCOUNT",
    "DISABLED",
    "NO TRANSFER ACCESS",
    "TRANSFER LIST IS FULL",
    "NO CLUB",
    "GENERAL LOGIN ERROR",
    "ERROR",
    "BLOCKED",
    "AMOUNT TAKEN",
}

# Database files
MONITORED_ACCOUNTS_FILE = "monitored_accounts.json"
STATS_FILE = "request_stats.json"
BURST_QUEUE_FILE = "burst_queue.json"

# Global vars
telegram_app = None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š Statistics & Tracking
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class RequestStats:
    """Track request statistics"""
    total_requests: int = 0
    csrf_refreshes: int = 0
    batch_fetches: int = 0
    cache_hits: int = 0
    cache_misses: int = 0
    errors: int = 0
    fast_detections: int = 0
    burst_activations: int = 0
    ttl_adjustments: int = 0
    fallback_uses: int = 0
    last_reset: str = datetime.now().isoformat()

    def save(self):
        try:
            with open(STATS_FILE, "w") as f:
                json.dump(asdict(self), f, indent=2)
        except Exception as e:
            logger.error(f"âŒ Error saving stats: {e}")

    @classmethod
    def load(cls):
        if Path(STATS_FILE).exists():
            try:
                with open(STATS_FILE, "r") as f:
                    data = json.load(f)
                return cls(**data)
            except:
                pass
        return cls()

stats = RequestStats.load()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Burst Mode Queue Manager
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class BurstAccount:
    """Account in burst mode"""
    email: str
    account_id: str
    start_time: datetime
    chat_id: int
    
    def is_active(self) -> bool:
        """Check if burst mode is still active"""
        elapsed = (datetime.now() - self.start_time).total_seconds()
        return elapsed < BURST_MODE_DURATION

class BurstQueueManager:
    """Manage accounts in burst mode"""
    
    def __init__(self):
        self.queue: List[BurstAccount] = []
        self.load_queue()
    
    def add(self, email: str, account_id: str, chat_id: int):
        """Add account to burst queue"""
        account = BurstAccount(
            email=email,
            account_id=account_id,
            start_time=datetime.now(),
            chat_id=chat_id
        )
        self.queue.append(account)
        self.save_queue()
        logger.info(f"ğŸš€ Added {email} to burst queue")
        stats.burst_activations += 1
    
    def get_active(self) -> List[BurstAccount]:
        """Get all active burst accounts"""
        active = [acc for acc in self.queue if acc.is_active()]
        # Clean up expired
        self.queue = active
        return active
    
    def remove(self, email: str):
        """Remove account from burst queue"""
        self.queue = [acc for acc in self.queue if acc.email != email]
        self.save_queue()
    
    def save_queue(self):
        """Save queue to file"""
        try:
            data = [
                {
                    "email": acc.email,
                    "account_id": acc.account_id,
                    "start_time": acc.start_time.isoformat(),
                    "chat_id": acc.chat_id
                }
                for acc in self.queue
            ]
            with open(BURST_QUEUE_FILE, "w") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"âŒ Error saving burst queue: {e}")
    
    def load_queue(self):
        """Load queue from file"""
        if Path(BURST_QUEUE_FILE).exists():
            try:
                with open(BURST_QUEUE_FILE, "r") as f:
                    data = json.load(f)
                self.queue = [
                    BurstAccount(
                        email=item["email"],
                        account_id=item["account_id"],
                        start_time=datetime.fromisoformat(item["start_time"]),
                        chat_id=item["chat_id"]
                    )
                    for item in data
                ]
                # Clean up expired on load
                self.queue = [acc for acc in self.queue if acc.is_active()]
            except Exception as e:
                logger.error(f"âŒ Error loading burst queue: {e}")

burst_queue = BurstQueueManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ” Smart Cache API Manager
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SmartCacheAPIManager:
    """API manager with smart caching and burst mode"""

    def __init__(self):
        self.base_url = CONFIG["website"]["urls"]["base"]
        self.cookies = CONFIG["website"]["cookies"]

        # CSRF Token cache
        self.csrf_token = None
        self.csrf_expires_at = None

        # Smart cache
        self.cache: Dict[str, Dict] = {}  # email -> account data
        self.cache_by_id: Dict[str, Dict] = {}  # account_id -> account data
        self.cache_timestamp = None
        self.cache_ttl = BASE_CACHE_TTL
        self.last_cache_data = None  # Fallback cache
        
        # Activity tracking for adaptive TTL
        self.recent_changes = 0
        self.last_check_time = datetime.now()

        # aiohttp session
        self.session = None

    async def initialize(self):
        """Initialize API manager"""
        await self._ensure_session()
        logger.info("ğŸš€ Smart Cache API Manager initialized")

    async def _ensure_session(self):
        """Ensure aiohttp session exists"""
        if self.session is None or self.session.closed:
            connector = aiohttp.TCPConnector(limit=10, limit_per_host=5)
            timeout = aiohttp.ClientTimeout(total=30)

            self.session = aiohttp.ClientSession(
                connector=connector, timeout=timeout, cookies=self.cookies
            )

    def _adjust_cache_ttl(self):
        """Adjust cache TTL based on activity"""
        global stats
        
        # Calculate change rate
        if self.recent_changes > 5:
            # High activity - reduce TTL
            self.cache_ttl = max(MIN_CACHE_TTL, self.cache_ttl - 30)
            logger.info(f"ğŸ“ˆ High activity detected, reduced TTL to {self.cache_ttl}s")
        elif self.recent_changes < 2:
            # Low activity - increase TTL
            self.cache_ttl = min(MAX_CACHE_TTL, self.cache_ttl + 30)
            logger.info(f"ğŸ“‰ Low activity, increased TTL to {self.cache_ttl}s")
        else:
            # Normal activity - gradually return to base
            if self.cache_ttl < BASE_CACHE_TTL:
                self.cache_ttl = min(BASE_CACHE_TTL, self.cache_ttl + 15)
            elif self.cache_ttl > BASE_CACHE_TTL:
                self.cache_ttl = max(BASE_CACHE_TTL, self.cache_ttl - 15)
        
        stats.ttl_adjustments += 1
        self.recent_changes = 0  # Reset counter

    def _is_cache_valid(self, force_refresh: bool = False) -> bool:
        """Check if cache is valid"""
        if force_refresh or not self.cache_timestamp:
            return False
        
        # Check if we're in burst mode
        if burst_queue.get_active():
            # During burst mode, cache expires faster
            ttl = BURST_REFRESH_INTERVAL
        else:
            ttl = self.cache_ttl
        
        age = (datetime.now() - self.cache_timestamp).total_seconds()
        return age < ttl

    async def _send_status_notification(
        self,
        email: str,
        account_id: str,
        old_status: str,
        new_status: str,
        chat_id: int,
        account_data: Dict,
        response_time: Optional[float] = None,
    ):
        """Send status change notification"""
        try:
            old_emoji = get_status_emoji(old_status)
            new_emoji = get_status_emoji(new_status)
            
            old_status_ar = get_status_description_ar(old_status)
            new_status_ar = get_status_description_ar(new_status)

            notification = (
                f"ğŸ”” *ØªÙ†Ø¨ÙŠÙ‡ ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©!*\n\n"
                f"ğŸ“§ Ø§Ù„Ø¨Ø±ÙŠØ¯: `{email}`\n"
                f"ğŸ†” ID: `{account_id}`\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©:*\n"
                f"   `{old_status}`\n"
                f"   {old_emoji} {old_status_ar}\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:*\n"
                f"   `{new_status}`\n"
                f"   {new_emoji} {new_status_ar}\n\n"
            )
            
            if response_time:
                speed_emoji = "âš¡âš¡" if response_time < 5 else "âš¡" if response_time < 10 else "ğŸš€"
                notification += f"{speed_emoji} ÙˆÙ‚Øª Ø§Ù„Ø§ÙƒØªØ´Ø§Ù: {response_time:.1f} Ø«Ø§Ù†ÙŠØ©\n"
            
            notification += f"ğŸ• Ø§Ù„ÙˆÙ‚Øª: {datetime.now().strftime('%H:%M:%S')}\n"

            available = format_number(account_data.get("Available", "0"))
            taken = format_number(account_data.get("Taken", "0"))

            if available != "0" or taken != "0":
                notification += f"\nğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {available}\nâœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {taken}\n"

            notification += f"\nğŸ’¡ `/search {email}` Ù„Ù„ØªÙØ§ØµÙŠÙ„"

            await telegram_app.bot.send_message(
                chat_id=chat_id, text=notification, parse_mode="Markdown"
            )

        except Exception as e:
            logger.error(f"âŒ Failed to send notification: {e}")

    async def get_csrf_token(self, force_refresh: bool = False) -> Optional[str]:
        """Get CSRF token with caching"""
        global stats

        if not force_refresh and self.csrf_token and self.csrf_expires_at:
            if datetime.now() < self.csrf_expires_at:
                stats.cache_hits += 1
                return self.csrf_token

        logger.info("ğŸ”„ Fetching CSRF token...")
        stats.csrf_refreshes += 1
        stats.total_requests += 1

        await self._ensure_session()

        try:
            async with self.session.get(f"{self.base_url}/senderPage") as response:
                if response.status == 200:
                    html = await response.text()
                    match = re.search(
                        r'<meta name="csrf-token" content="([^"]+)"', html
                    )
                    if match:
                        self.csrf_token = match.group(1)
                        self.csrf_expires_at = datetime.now() + timedelta(
                            seconds=CSRF_TOKEN_TTL
                        )
                        logger.info(f"âœ… CSRF cached ({CSRF_TOKEN_TTL}s)")
                        return self.csrf_token
        except Exception as e:
            logger.error(f"âŒ CSRF fetch error: {e}")
            stats.errors += 1

        return None

    async def refresh_cache(self, force: bool = False) -> bool:
        """Refresh the accounts cache"""
        global stats
        
        if not force and self._is_cache_valid():
            stats.cache_hits += 1
            return True
        
        logger.info(f"ğŸ”„ Refreshing cache (TTL: {self.cache_ttl}s)...")
        stats.batch_fetches += 1
        stats.total_requests += 1

        csrf = await self.get_csrf_token()
        if not csrf:
            # Fallback to last cache if available
            if self.last_cache_data:
                logger.warning("âš ï¸ Using fallback cache due to CSRF failure")
                stats.fallback_uses += 1
                return True
            return False

        await self._ensure_session()

        try:
            payload = {"date": "0", "bigUpdate": "0", "csrf_token": csrf}

            async with self.session.post(
                f"{self.base_url}/dataFunctions/updateSenderPage", data=payload
            ) as response:

                if response.status == 200:
                    data = await response.json()

                    if "data" in data:
                        accounts = data["data"]

                        INDEX_MAP = {
                            "idAccount": 0,
                            "image": 1,
                            "Sender": 2,
                            "Start": 3,
                            "Last Update": 4,
                            "Taken": 5,
                            "Status": 6,
                            "Available": 7,
                            "password": 8,
                            "backupCodes": 9,
                            "Group": 10,
                            "groupNameId": 11,
                            "Take": 12,
                            "Keep": 13,
                        }

                        # Clear old cache
                        old_cache = self.cache.copy()
                        self.cache.clear()
                        self.cache_by_id.clear()
                        
                        # Build new cache
                        changes_detected = 0
                        for account in accounts:
                            if len(account) > INDEX_MAP["Sender"]:
                                acc = {}
                                for key, idx in INDEX_MAP.items():
                                    acc[key] = (
                                        str(account[idx])
                                        if idx < len(account) and account[idx]
                                        else ""
                                    )
                                
                                email = acc.get("Sender", "").lower()
                                account_id = acc.get("idAccount", "")
                                
                                if email:
                                    # Check for changes
                                    if email in old_cache:
                                        old_status = old_cache[email].get("Status", "")
                                        new_status = acc.get("Status", "")
                                        if old_status != new_status:
                                            changes_detected += 1
                                    
                                    self.cache[email] = acc
                                    if account_id:
                                        self.cache_by_id[account_id] = acc
                        
                        self.cache_timestamp = datetime.now()
                        self.last_cache_data = self.cache.copy()
                        self.recent_changes += changes_detected
                        
                        # Adjust TTL based on activity
                        if (datetime.now() - self.last_check_time).total_seconds() > 300:
                            self._adjust_cache_ttl()
                            self.last_check_time = datetime.now()

                        logger.info(f"âœ… Cache refreshed: {len(self.cache)} accounts, {changes_detected} changes")
                        return True

                elif response.status in [403, 419]:
                    self.csrf_token = None
                    # Try again with new CSRF
                    return await self.refresh_cache(force=True)

        except Exception as e:
            logger.error(f"âŒ Cache refresh error: {e}")
            stats.errors += 1
            
            # Use fallback cache
            if self.last_cache_data:
                logger.warning("âš ï¸ Using fallback cache due to error")
                stats.fallback_uses += 1
                return True

        return False

    async def get_account_by_email(self, email: str) -> Optional[Dict]:
        """Get account from cache by email"""
        email = email.lower().strip()
        
        # Ensure cache is fresh
        await self.refresh_cache()
        
        if email in self.cache:
            stats.cache_hits += 1
            return self.cache[email]
        else:
            stats.cache_misses += 1
            return None
    
    async def get_account_by_id(self, account_id: str) -> Optional[Dict]:
        """Get account from cache by ID (strict validation)"""
        # Ensure cache is fresh
        await self.refresh_cache()
        
        if account_id in self.cache_by_id:
            stats.cache_hits += 1
            return self.cache_by_id[account_id]
        else:
            stats.cache_misses += 1
            return None

    async def add_sender(
        self,
        email: str,
        password: str,
        backup_codes: str = "",
        amount_take: str = "",
        amount_keep: str = "",
    ) -> Tuple[bool, str]:
        """Add sender"""
        global stats

        csrf = await self.get_csrf_token()
        if not csrf:
            return False, "No CSRF"

        stats.total_requests += 1
        await self._ensure_session()

        defaults = CONFIG["website"]["defaults"]
        payload = {
            "email": email,
            "password": password,
            "backupCodes": backup_codes,
            "groupName": defaults["group_name"],
            "accountLock": defaults["account_lock"],
            "amountToTake": amount_take or defaults.get("amount_take", ""),
            "amountToKeep": amount_keep or defaults.get("amount_keep", ""),
            "priority": defaults.get("priority", ""),
            "forceProxy": defaults.get("force_proxy", ""),
            "userPrice": defaults.get("user_price", ""),
            "csrf_token": csrf,
        }

        try:
            async with self.session.post(
                f"{self.base_url}/dataFunctions/addAccount", json=payload
            ) as response:

                if response.status == 200:
                    try:
                        data = await response.json()
                        if "success" in data:
                            # Force cache refresh after adding
                            await self.refresh_cache(force=True)
                            return True, data.get("success", "Success")
                        elif "error" in data:
                            error = data.get("error", "")
                            if "already" in error.lower():
                                return True, "Exists"
                            return False, error
                    except:
                        text = await response.text()
                        if "success" in text.lower():
                            await self.refresh_cache(force=True)
                            return True, "Success"
                        return False, text[:100]

                elif response.status in [403, 419]:
                    self.csrf_token = None
                    return False, "CSRF expired"

                return False, f"Status {response.status}"

        except Exception as e:
            stats.errors += 1
            return False, str(e)

    async def close(self):
        """Cleanup"""
        if self.session and not self.session.closed:
            await self.session.close()

# Global API manager
api_manager = SmartCacheAPIManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¾ Database Functions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def load_monitored_accounts() -> Dict:
    if Path(MONITORED_ACCOUNTS_FILE).exists():
        try:
            with open(MONITORED_ACCOUNTS_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except:
            pass
    return {}

def save_monitored_accounts(accounts: Dict):
    try:
        with open(MONITORED_ACCOUNTS_FILE, "w", encoding="utf-8") as f:
            json.dump(accounts, f, indent=2, ensure_ascii=False)
    except Exception as e:
        logger.error(f"âŒ Save error: {e}")

def add_monitored_account(email: str, account_id: str, status: str, chat_id: int):
    accounts = load_monitored_accounts()
    accounts[email] = {
        "account_id": account_id,  # Store trusted ID
        "last_known_status": status,
        "chat_id": chat_id,
        "added_at": datetime.now().isoformat(),
        "last_check": datetime.now().isoformat(),
    }
    save_monitored_accounts(accounts)

def update_monitored_account_status(email: str, new_status: str):
    accounts = load_monitored_accounts()
    if email in accounts:
        accounts[email]["last_known_status"] = new_status
        accounts[email]["last_check"] = datetime.now().isoformat()
        save_monitored_accounts(accounts)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ Helper Functions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def is_admin(user_id: int) -> bool:
    admin_ids = CONFIG["telegram"].get("admin_ids", [])
    return not admin_ids or user_id in admin_ids

def format_number(value) -> str:
    if value is None or value == "" or value == "null":
        return "0"

    try:
        value_str = str(value).strip()
        if not value_str.replace(".", "", 1).replace("-", "", 1).isdigit():
            return value_str

        num = float(value_str)

        if abs(num) < 1000:
            return str(int(num)) if num == int(num) else str(num)

        k_value = num / 1000

        if abs(k_value) >= 1000:
            return f"{k_value:,.0f}k"
        else:
            return f"{int(k_value)}k"
    except:
        return str(value)

def get_status_emoji(status: str) -> str:
    """Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ emoji Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø­Ø§Ù„Ø©"""
    emoji_map = {
        "LOGGING": "ğŸ”„",
        "LOGGED": "âœ…",
        "LOGGED IN": "ğŸ‘¤",
        "ACTIVE": "âœ…",
        "AVAILABLE": "ğŸ’°",
        "CODE SENT": "ğŸ“§",
        "AMOUNT TAKEN": "ğŸ’¸",
        "WRONG DETAILS": "âš ï¸",
        "NEW ACCOUNT": "ğŸ†•",
        "DISABLED": "ğŸ”’",
        "NO TRANSFER ACCESS": "ğŸš«",
        "BACKUP CODE WRONG": "ğŸ”‘",
        "TRANSFER LIST IS FULL": "ğŸ“¦",
        "NO CLUB": "â›”",
        "GENERAL LOGIN ERROR": "â—",
        "ERROR": "âŒ",
        "WAITING": "â³",
        "BLOCKED": "ğŸš«",
        "INVALID": "âŒ",
        "FAILED": "âŒ",
    }

    return emoji_map.get(status.upper(), "ğŸ“Š")

def get_status_description_ar(status: str) -> str:
    """Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ ÙˆØµÙ Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠ"""
    descriptions = {
        "LOGGING": "Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        "LOGGED": "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        "LOGGED IN": "Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¯Ø®Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨",
        "ACTIVE": "Ù†Ø´Ø·",
        "AVAILABLE": "Ù…ØªØ§Ø­ - Ø§Ù„Ø­Ø³Ø§Ø¨ ØªÙ…Ø§Ù… ÙˆØ¬Ø§Ù‡Ø² Ù„Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª",
        "CODE SENT": "Ø§Ù„ÙƒÙˆØ¯ Ø§ØªØ¨Ø¹Øª",
        "AMOUNT TAKEN": "Ø§Ù„ÙÙ„ÙˆØ³ (Ø§Ù„ÙƒÙˆÙŠÙ†Ø²) Ø§ØªØ£Ø®Ø¯Øª ÙˆØ§Ù„ÙƒÙˆÙŠÙ†Ø² Ø§ØªÙ†Ù‚Ù„Øª",
        "WRONG DETAILS": "Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙ„Ø· - Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ø£Ùˆ Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯ Ø£Ùˆ Ø§Ù„Ù€ EA Account Ù…Ø´ ØµØ­",
        "NEW ACCOUNT": "Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯ - Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯ ÙˆÙ…Ø§ ÙÙŠÙ‡ÙˆØ´ Ù„Ø§Ø¹ÙŠØ¨Ø© ÙƒÙØ§ÙŠØ©",
        "DISABLED": "Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø·Ù„",
        "NO TRANSFER ACCESS": "Ù…Ø§Ø±ÙƒØª Ù…Ù‚ÙÙˆÙ„ - ÙˆÙŠØ¨ Ø§Ø¨ Ù…Ù‚ÙÙˆÙ„ - Companion Ù…Ù‚ÙÙˆÙ„",
        "BACKUP CODE WRONG": "Ø§ÙƒÙˆØ§Ø¯ ØºÙ„Ø· - Ø¬Ø¯Ø¯ Ø§ÙƒÙˆØ§Ø¯ ÙˆØ§Ø¨Ø¹ØªÙ‡Ù… ØªØ§Ù†ÙŠ",
        "TRANSFER LIST IS FULL": "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª ÙƒØ§Ù…Ù„Ø© - ÙØ¶ÙŠ Ù…Ø§Ø±ÙƒØª Ø´ÙˆÙŠØ© ÙˆØ§Ø¨Ø¹Øª (Ù„Ø§Ø¹ÙŠØ¨Ø©)",
        "NO CLUB": "Ù…Ø§ ÙÙŠØ´ ÙƒÙ„ÙˆØ¨",
        "GENERAL LOGIN ERROR": "Ù…Ø´ÙƒÙ„Ø© Ø¹Ø§Ù…Ø© ÙÙŠ Ø§Ù„Ø¯Ø®ÙˆÙ„ - Ø®Ø·Ø£ Ø¹Ø´ÙˆØ§Ø¦ÙŠ ÙÙŠ Ø§Ù„Ù„ÙˆØ¬ Ø¥Ù†",
        "ERROR": "Ø®Ø·Ø£ Ø¹Ø§Ù…",
        "WAITING": "Ù…Ù†ØªØ¸Ø±",
        "BLOCKED": "Ù…Ø­Ø¸ÙˆØ±",
    }

    return descriptions.get(status.upper(), status)

def parse_sender_data(text: str) -> Dict:
    lines = text.strip().split("\n")
    data = {
        "email": "",
        "password": "",
        "codes": [],
        "amount_take": "",
        "amount_keep": "",
    }

    email_pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"

    for line in lines:
        line = line.strip()
        if not line:
            continue

        if re.match(email_pattern, line):
            data["email"] = line.lower()
        elif "Ø§Ø³Ø­Ø¨" in line:
            match = re.search(r"Ø§Ø³Ø­Ø¨\s*(\d+)", line)
            if match:
                data["amount_take"] = match.group(1)
        elif "ÙŠØ³ÙŠØ¨" in line:
            match = re.search(r"ÙŠØ³ÙŠØ¨\s*(\d+)", line)
            if match:
                data["amount_keep"] = match.group(1)
        elif re.match(r"^[\d.]+$", line):
            clean_code = line.split(".")[-1] if "." in line else line
            data["codes"].append(clean_code)
        elif data["email"] and not data["password"]:
            data["password"] = line

    data["codes"] = ",".join(data["codes"])
    return data

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš¡ Smart Burst Mode Monitoring
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def wait_for_status_change(
    email: str, message_obj, chat_id: int
) -> Tuple[bool, Optional[Dict]]:
    """
    ğŸš€ Smart monitoring with burst mode
    
    Strategy:
    - Add to burst queue for 60 seconds of fast updates
    - Monitor from cache (no network requests)
    - Ultra-fast response (2-5 seconds)
    """
    
    global stats
    
    start_time = datetime.now()
    last_status = None
    status_changes = []
    stable_count = 0
    max_duration = 120  # 2 minutes max
    
    # First refresh to ensure we have the account
    await api_manager.refresh_cache(force=True)
    
    # Get initial account info
    account_info = await api_manager.get_account_by_email(email)
    
    if account_info:
        account_id = account_info.get("idAccount", "")
        # Add to burst queue for fast updates
        burst_queue.add(email, account_id, chat_id)
        logger.info(f"ğŸš€ Activated burst mode for {email}")
    
    check_count = 0
    
    while (datetime.now() - start_time).total_seconds() < max_duration:
        check_count += 1
        
        # Get account from cache (no network request)
        account_info = await api_manager.get_account_by_email(email)
        
        if not account_info:
            # Account not found yet
            await message_obj.edit_text(
                f"ğŸ” *Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù€ Cache*\n\n"
                f"ğŸ“§ `{email}`\n"
                f"ğŸ”„ Ø§Ù„ØªØ­Ù‚Ù‚: {check_count}\n"
                f"â±ï¸ Ø§Ù„ÙˆÙ‚Øª: {int((datetime.now() - start_time).total_seconds())}s\n"
                f"ğŸ’¾ Cache Mode",
                parse_mode="Markdown",
            )
            
            await asyncio.sleep(1.0)  # Short wait
            continue
        
        # Account found
        status = account_info.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯").upper()
        account_id = account_info.get("idAccount", "N/A")
        
        # Track status changes
        if status != last_status:
            elapsed = (datetime.now() - start_time).total_seconds()
            logger.info(f"ğŸ“Š {email}: {last_status} â†’ {status} at {elapsed:.1f}s")
            
            status_changes.append({
                "status": status,
                "time": datetime.now(),
                "elapsed": elapsed
            })
            
            if last_status and status in FINAL_STATUSES:
                stats.fast_detections += 1
                logger.info(f"âš¡ Fast detection: {status} in {elapsed:.1f}s")
            
            last_status = status
            stable_count = 0
        else:
            stable_count += 1
        
        # Determine status type
        is_final = status in FINAL_STATUSES
        is_transitional = status in TRANSITIONAL_STATUSES
        
        # Update message
        status_ar = get_status_description_ar(status)
        status_type = "âœ… Ù†Ù‡Ø§Ø¦ÙŠØ©" if is_final else "â³ Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ©" if is_transitional else "â“ ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©"
        
        # Show change history
        changes_text = ""
        if len(status_changes) > 1:
            changes_text = "\nğŸ“ *Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª:*\n"
            for change in status_changes[-3:]:
                changes_text += f"   â€¢ `{change['status']}` ({change['elapsed']:.1f}s)\n"
        
        # Burst mode indicator
        is_burst_active = any(acc.email == email for acc in burst_queue.get_active())
        mode_text = "ğŸš€ BURST MODE" if is_burst_active else "ğŸ”„ NORMAL MODE"
        
        elapsed = (datetime.now() - start_time).total_seconds()
        
        await message_obj.edit_text(
            f"{mode_text}\n\n"
            f"ğŸ“§ `{email}`\n"
            f"ğŸ†” ID: `{account_id}`\n\n"
            f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø©:* `{status}`\n"
            f"   {get_status_emoji(status)} {status_ar}\n"
            f"   ğŸ¯ {status_type}\n"
            f"{changes_text}\n"
            f"â±ï¸ Ø§Ù„ÙˆÙ‚Øª: {elapsed:.1f}s\n"
            f"ğŸ”„ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±: {stable_count}/3\n"
            f"ğŸ’¾ Ù…Ù† Ø§Ù„Ù€ Cache (Ø³Ø±ÙŠØ¹ Ø¬Ø¯Ø§Ù‹)",
            parse_mode="Markdown",
        )
        
        # Decision logic
        if is_final and stable_count >= 3:
            # Stable final status
            response_time = (datetime.now() - start_time).total_seconds()
            logger.info(f"âœ… {email}: Stable at {status} in {response_time:.1f}s")
            
            # Remove from burst queue
            burst_queue.remove(email)
            
            # Add to monitoring
            if status in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
                add_monitored_account(email, account_id, status, chat_id)
            
            return True, account_info
        
        # Wait before next check
        if is_burst_active:
            await asyncio.sleep(0.5)  # Very fast in burst mode
        else:
            await asyncio.sleep(2.0)  # Normal speed
    
    # Timeout reached
    logger.warning(f"â±ï¸ {email}: Timeout at {last_status}")
    burst_queue.remove(email)
    
    if account_info:
        status = account_info.get("Status", "").upper()
        if status in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
            add_monitored_account(email, account_id, status, chat_id)
    
    return True, account_info

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ Background Monitors
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def cache_refresher():
    """Background task to refresh cache"""
    logger.info("ğŸ’¾ Cache refresher started")
    
    while True:
        try:
            # Check if burst mode is active
            active_burst = burst_queue.get_active()
            
            if active_burst:
                # Burst mode - refresh every 2 seconds
                await asyncio.sleep(BURST_REFRESH_INTERVAL)
                await api_manager.refresh_cache(force=True)
                logger.debug(f"ğŸš€ Burst refresh for {len(active_burst)} accounts")
            else:
                # Normal mode - use adaptive TTL
                await asyncio.sleep(30)  # Check every 30 seconds
                await api_manager.refresh_cache()
                
        except Exception as e:
            logger.exception("âŒ Cache refresher error")
            await asyncio.sleep(10)

async def continuous_monitor():
    """Monitor all tracked accounts for changes"""
    logger.info("ğŸ”„ Continuous monitor started")
    
    while True:
        try:
            accounts = load_monitored_accounts()
            
            if not accounts:
                await asyncio.sleep(30)
                continue
            
            # Ensure cache is fresh
            await api_manager.refresh_cache()
            
            for email, data in accounts.items():
                try:
                    # Use strict ID validation
                    account_id = data.get("account_id")
                    if not account_id:
                        continue
                    
                    # Get by trusted ID
                    account_info = await api_manager.get_account_by_id(account_id)
                    
                    if not account_info:
                        logger.warning(f"âš ï¸ Account {email} (ID: {account_id}) not found")
                        continue
                    
                    current_status = account_info.get("Status", "").upper()
                    last_status = data.get("last_known_status", "").upper()
                    
                    if current_status != last_status:
                        logger.info(f"ğŸ”” {email}: {last_status} â†’ {current_status}")
                        
                        update_monitored_account_status(email, current_status)
                        
                        # Send notification
                        await api_manager._send_status_notification(
                            email,
                            account_id,
                            last_status,
                            current_status,
                            data["chat_id"],
                            account_info,
                        )
                    
                except Exception as e:
                    logger.exception(f"âŒ Error monitoring {email}")
            
            # Wait based on cache TTL
            await asyncio.sleep(api_manager.cache_ttl / 2)
            
        except Exception as e:
            logger.exception("âŒ Monitor error")
            await asyncio.sleep(30)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ Bot Commands
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command"""
    user = update.effective_user

    if not is_admin(user.id):
        await update.message.reply_text("âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†.")
        return

    welcome_msg = (
        f"Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.first_name}! ğŸ‘‹\n\n"
        "ğŸš€ *Ø¨ÙˆØª Ø§Ù„Ø³ÙŠÙ†Ø¯Ø±Ø² - Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù‡Ø¬ÙŠÙ† Ø§Ù„Ù…ØªÙƒÙŠÙ*\n"
        "ğŸ’¾ *Smart Cache + Burst Mode*\n\n"
        "*ğŸ“ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¥Ø¶Ø§ÙØ©:*\n"
        "```\n"
        "email@gmail.com\n"
        "password123\n"
        "12345678\n"
        "Ø§Ø³Ø­Ø¨ 100\n"
        "ÙŠØ³ÙŠØ¨ 50\n"
        "```\n\n"
        "*âš¡ Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©:*\n"
        "â€¢ ğŸ’¾ Smart Cache: Ø¬Ù„Ø¨ Ù…Ø±ÙƒØ²ÙŠ + Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø­Ù„ÙŠØ©\n"
        "â€¢ ğŸš€ Burst Mode: 60 Ø«Ø§Ù†ÙŠØ© ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 2 Ø«Ø§Ù†ÙŠØ©\n"
        "â€¢ ğŸ¯ Strict ID Validation: ØªØ­Ù‚Ù‚ Ø¯Ù‚ÙŠÙ‚ Ø¨Ø§Ù„Ù€ ID\n"
        "â€¢ ğŸ“ˆ Adaptive TTL: ÙŠØªÙƒÙŠÙ Ø­Ø³Ø¨ Ø§Ù„Ù†Ø´Ø§Ø·\n"
        "â€¢ ğŸ”„ Fallback Cache: Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø­ØªÙ‰ Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡\n\n"
        "*â±ï¸ Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:*\n"
        "â€¢ Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ØªØºÙŠÙŠØ±: 2-5 Ø«ÙˆØ§Ù†ÙŠ\n"
        "â€¢ Ø¨Ø¯ÙˆÙ† Ø·Ù„Ø¨Ø§Øª Ø´Ø¨ÙƒØ© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©\n"
        "â€¢ ÙƒÙØ§Ø¡Ø© Ø¹Ø§Ù„ÙŠØ© ÙˆØ­Ù…Ø§ÙŠØ© Ù…Ù† Ø§Ù„Ø­Ø¸Ø±\n\n"
        "*ğŸ” Ø§Ù„Ø£ÙˆØ§Ù…Ø±:*\n"
        "`/search email` - Ø¨Ø­Ø«\n"
        "`/monitored` - Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©\n"
        "`/stats` - Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª\n"
        "`/status` - Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…\n"
        "`/cache` - Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù€ Cache"
    )

    await update.message.reply_text(welcome_msg, parse_mode="Markdown")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle adding senders"""

    if not is_admin(update.effective_user.id):
        return

    if update.message.text.startswith("/"):
        return

    data = parse_sender_data(update.message.text)

    if not data["email"] or not data["password"]:
        await update.message.reply_text("âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©!")
        return

    msg = await update.message.reply_text(
        f"â³ *Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø¶Ø§ÙØ©...*\nğŸ“§ `{data['email']}`", parse_mode="Markdown"
    )

    try:
        success, message = await api_manager.add_sender(
            email=data["email"],
            password=data["password"],
            backup_codes=data["codes"],
            amount_take=data["amount_take"],
            amount_keep=data["amount_keep"],
        )

        if success:
            await msg.edit_text(
                f"âœ… *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©!*\n"
                f"ğŸ“§ `{data['email']}`\n\n"
                f"ğŸš€ *ØªÙØ¹ÙŠÙ„ BURST MODE*\n"
                f"âš¡ ØªØ­Ø¯ÙŠØ« Ø³Ø±ÙŠØ¹ Ù„Ù…Ø¯Ø© 60 Ø«Ø§Ù†ÙŠØ©\n"
                f"â±ï¸ Ù…ØªÙˆÙ‚Ø¹: 2-5 Ø«ÙˆØ§Ù†ÙŠ",
                parse_mode="Markdown",
            )

            start_time = datetime.now()
            monitoring_success, account_info = await wait_for_status_change(
                data["email"], msg, update.effective_chat.id
            )
            response_time = (datetime.now() - start_time).total_seconds()

            if account_info:
                status = account_info.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
                status_ar = get_status_description_ar(status)
                
                result_text = (
                    f"âœ… *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø¨Ù†Ø¬Ø§Ø­!*\n\n"
                    f"ğŸ“§ `{data['email']}`\n"
                    f"ğŸ†” ID: `{account_info.get('idAccount', 'N/A')}`\n\n"
                    f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:*\n"
                    f"   `{status}`\n"
                    f"   {get_status_emoji(status)} {status_ar}\n\n"
                )
                
                if response_time < 5:
                    result_text += f"âš¡âš¡ *Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙØ§Ø¦Ù‚Ø©: {response_time:.1f}s*\n"
                elif response_time < 10:
                    result_text += f"âš¡ *Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø³Ø±ÙŠØ¹Ø©: {response_time:.1f}s*\n"
                else:
                    result_text += f"ğŸš€ *ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©: {response_time:.1f}s*\n"

                if status.upper() in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
                    result_text += f"ğŸ”„ *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©!*\n"
                elif status.upper() in ["WRONG DETAILS", "BACKUP CODE WRONG"]:
                    result_text += f"âš ï¸ *ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!*\n"

                available = format_number(account_info.get("Available", "0"))
                taken = format_number(account_info.get("Taken", "0"))

                if available != "0" or taken != "0":
                    result_text += f"\nğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {available}\nâœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {taken}"

                await msg.edit_text(result_text, parse_mode="Markdown")

        else:
            await msg.edit_text(
                f"âŒ *ÙØ´Ù„Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©*\nğŸ“§ `{data['email']}`\nâš ï¸ {message}",
                parse_mode="Markdown",
            )

    except Exception as e:
        logger.exception(f"âŒ Error: {data['email']}")
        await msg.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Search sender"""

    if not is_admin(update.effective_user.id):
        return

    if not context.args:
        await update.message.reply_text(
            "ğŸ“ `/search email@example.com`", parse_mode="Markdown"
        )
        return

    email = context.args[0].strip().lower()
    msg = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...")

    try:
        # Force cache refresh for fresh data
        await api_manager.refresh_cache(force=True)
        result = await api_manager.get_account_by_email(email)

        if result:
            status = result.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
            status_ar = get_status_description_ar(status)
            
            status_type = (
                "Ù†Ù‡Ø§Ø¦ÙŠØ© âœ…"
                if status in FINAL_STATUSES
                else "Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ© â³" if status in TRANSITIONAL_STATUSES else "ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø© â“"
            )

            text = (
                f"âœ… *ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ±*\n\n"
                f"ğŸ“§ `{result.get('Sender', email)}`\n"
                f"ğŸ†” ID: `{result.get('idAccount', 'N/A')}`\n"
                f"ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: {result.get('Group', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø©:* `{status}`\n"
                f"   {get_status_emoji(status)} {status_ar}\n"
                f"   ğŸ¯ {status_type}\n\n"
                f"ğŸ“… Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©: {format_number(result.get('Start', '0'))}\n"
                f"ğŸ• Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {result.get('Last Update', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}\n"
                f"ğŸ’° Ø§Ø³Ø­Ø¨: {format_number(result.get('Take', '0'))}\n"
                f"ğŸ’¸ ÙŠØ³ÙŠØ¨: {format_number(result.get('Keep', '0'))}\n"
                f"âœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {format_number(result.get('Taken', '0'))}\n"
                f"ğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {format_number(result.get('Available', '0'))}"
            )

            accounts = load_monitored_accounts()
            if email in accounts:
                text += f"\n\nğŸ”„ *Ù…Ø±Ø§Ù‚Ø¨ Ø¨Ø§Ù„Ù€ ID:* `{accounts[email]['account_id']}`"

            await msg.edit_text(text, parse_mode="Markdown")
        else:
            await msg.edit_text(f"âŒ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: `{email}`", parse_mode="Markdown")

    except Exception as e:
        await msg.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def monitored(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show monitored accounts"""

    if not is_admin(update.effective_user.id):
        return

    accounts = load_monitored_accounts()

    if not accounts:
        await update.message.reply_text("ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ø±Ø§Ù‚Ø¨Ø©")
        return

    text = f"ğŸ”„ *Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ({len(accounts)})*\n\n"

    for email, data in accounts.items():
        status = data["last_known_status"]
        status_ar = get_status_description_ar(status)
        
        text += (
            f"ğŸ“§ `{email}`\n"
            f"   ğŸ†” `{data['account_id']}`\n"
            f"   ğŸ“Š *{status}*\n"
            f"   {get_status_emoji(status)} {status_ar}\n\n"
        )

    text += "ğŸ’¾ Smart Cache + ID Validation"

    await update.message.reply_text(text, parse_mode="Markdown")

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show stats"""

    if not is_admin(update.effective_user.id):
        return

    global stats

    reset_time = datetime.fromisoformat(stats.last_reset)
    hours = max((datetime.now() - reset_time).seconds / 3600, 0.01)
    requests_per_hour = stats.total_requests / hours
    cache_efficiency = (stats.cache_hits / max(stats.cache_hits + stats.cache_misses, 1)) * 100

    text = (
        "ğŸ“Š *Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©*\n\n"
        f"*ğŸ“ˆ Ø§Ù„Ø·Ù„Ø¨Ø§Øª:*\n"
        f"â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {stats.total_requests}\n"
        f"â€¢ Ø§Ù„Ù…Ø¹Ø¯Ù„: {requests_per_hour:.1f}/Ø³Ø§Ø¹Ø©\n"
        f"â€¢ CSRF: {stats.csrf_refreshes}\n"
        f"â€¢ Batch: {stats.batch_fetches}\n\n"
        f"*ğŸ’¾ Ø§Ù„Ù€ Cache:*\n"
        f"â€¢ Hits: {stats.cache_hits}\n"
        f"â€¢ Misses: {stats.cache_misses}\n"
        f"â€¢ Ø§Ù„ÙƒÙØ§Ø¡Ø©: {cache_efficiency:.1f}%\n"
        f"â€¢ TTL Ø§Ù„Ø­Ø§Ù„ÙŠ: {api_manager.cache_ttl}s\n"
        f"â€¢ ØªØ¹Ø¯ÙŠÙ„Ø§Øª TTL: {stats.ttl_adjustments}\n\n"
        f"*âš¡ Ø§Ù„Ø£Ø¯Ø§Ø¡:*\n"
        f"â€¢ Ø§ÙƒØªØ´Ø§ÙØ§Øª Ø³Ø±ÙŠØ¹Ø©: {stats.fast_detections}\n"
        f"â€¢ Burst ØªÙØ¹ÙŠÙ„Ø§Øª: {stats.burst_activations}\n"
        f"â€¢ Fallback Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Øª: {stats.fallback_uses}\n"
        f"â€¢ Ø£Ø®Ø·Ø§Ø¡: {stats.errors}\n\n"
        f"ğŸ• Ù…Ù†Ø°: {reset_time.strftime('%Y-%m-%d %H:%M:%S')}"
    )

    await update.message.reply_text(text, parse_mode="Markdown")

async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show system status"""

    if not is_admin(update.effective_user.id):
        return

    accounts = load_monitored_accounts()
    active_burst = burst_queue.get_active()
    csrf_valid = api_manager.csrf_expires_at and datetime.now() < api_manager.csrf_expires_at
    cache_valid = api_manager._is_cache_valid()
    cache_age = (datetime.now() - api_manager.cache_timestamp).total_seconds() if api_manager.cache_timestamp else 0

    text = (
        "*ğŸ“Š Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…*\n\n"
        f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: âœ… Ø´ØºØ§Ù„\n"
        f"âš¡ Ø§Ù„ÙˆØ¶Ø¹: *{'BURST MODE ğŸš€' if active_burst else 'NORMAL MODE ğŸ”„'}*\n\n"
        f"*ğŸ’¾ Ø§Ù„Ù€ Cache:*\n"
        f"â€¢ Ø§Ù„Ø­Ø§Ù„Ø©: {'âœ… ØµØ§Ù„Ø­' if cache_valid else 'âš ï¸ ÙŠØ­ØªØ§Ø¬ ØªØ­Ø¯ÙŠØ«'}\n"
        f"â€¢ Ø§Ù„Ø¹Ù…Ø±: {int(cache_age)}s\n"
        f"â€¢ TTL: {api_manager.cache_ttl}s\n"
        f"â€¢ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª: {len(api_manager.cache)}\n"
        f"â€¢ Fallback: {'âœ… Ù…ØªØ§Ø­' if api_manager.last_cache_data else 'âŒ ØºÙŠØ± Ù…ØªØ§Ø­'}\n\n"
        f"*ğŸ”‘ CSRF:*\n"
        f"â€¢ Ø§Ù„Ø­Ø§Ù„Ø©: {'âœ… ØµØ§Ù„Ø­' if csrf_valid else 'âš ï¸ Ù…Ù†ØªÙ‡ÙŠ'}\n\n"
        f"*ğŸ”„ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©:*\n"
        f"â€¢ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª: {len(accounts)}\n"
        f"â€¢ Burst Ù†Ø´Ø·: {len(active_burst)}\n\n"
        f"*âš¡ Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:*\n"
        f"â€¢ Smart Cache: âœ…\n"
        f"â€¢ Burst Mode: âœ…\n"
        f"â€¢ Adaptive TTL: âœ…\n"
        f"â€¢ ID Validation: âœ…\n"
        f"â€¢ Fallback Cache: âœ…"
    )

    await update.message.reply_text(text, parse_mode="Markdown")

async def cache_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show cache info"""
    
    if not is_admin(update.effective_user.id):
        return
    
    cache_size = len(api_manager.cache)
    cache_age = (datetime.now() - api_manager.cache_timestamp).total_seconds() if api_manager.cache_timestamp else 0
    
    # Sample of cached accounts
    sample_text = ""
    if api_manager.cache:
        for email, data in list(api_manager.cache.items())[:5]:
            status = data.get("Status", "N/A")
            sample_text += f"â€¢ {email}: {status}\n"
    
    text = (
        "*ğŸ’¾ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù€ Cache*\n\n"
        f"ğŸ“Š Ø§Ù„Ø­Ø¬Ù…: {cache_size} Ø­Ø³Ø§Ø¨\n"
        f"â±ï¸ Ø§Ù„Ø¹Ù…Ø±: {int(cache_age)} Ø«Ø§Ù†ÙŠØ©\n"
        f"ğŸ”„ TTL: {api_manager.cache_ttl} Ø«Ø§Ù†ÙŠØ©\n"
        f"ğŸ“ˆ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø©: {api_manager.recent_changes}\n\n"
        f"*ğŸ“ Ø¹ÙŠÙ†Ø© Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª:*\n{sample_text}\n"
        f"ğŸ’¡ Ø§Ø³ØªØ®Ø¯Ù… `/status` Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£ÙƒØ«Ø±"
    )
    
    await update.message.reply_text(text, parse_mode="Markdown")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Main Function
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    """Start the bot"""
    global telegram_app

    print("\n" + "=" * 60)
    print("ğŸš€ SMART SENDER BOT - HYBRID ADAPTIVE MODE")
    print("=" * 60)
    print("ğŸ’¾ Architecture:")
    print("   â€¢ Smart Cache: Central fetching + Local monitoring")
    print("   â€¢ Burst Mode: 60s of 2-second updates")
    print("   â€¢ Adaptive TTL: Adjusts based on activity")
    print("   â€¢ Strict ID Validation: Prevents data mix-ups")
    print("   â€¢ Fallback Cache: Continues on errors")
    print("\nâš¡ Performance:")
    print("   â€¢ Detection time: 2-5 seconds")
    print("   â€¢ No network requests during monitoring")
    print("   â€¢ High efficiency & rate limit protection")
    print("=" * 60 + "\n")

    telegram_app = Application.builder().token(CONFIG["telegram"]["bot_token"]).build()

    telegram_app.add_handler(CommandHandler("start", start))
    telegram_app.add_handler(CommandHandler("search", search))
    telegram_app.add_handler(CommandHandler("monitored", monitored))
    telegram_app.add_handler(CommandHandler("stats", stats_command))
    telegram_app.add_handler(CommandHandler("status", status_command))
    telegram_app.add_handler(CommandHandler("cache", cache_command))
    telegram_app.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text)
    )

    async def init_manager(_):
        await api_manager.initialize()
        # Start background tasks
        asyncio.create_task(cache_refresher())
        asyncio.create_task(continuous_monitor())

    telegram_app.job_queue.run_once(init_manager, when=1)

    print("âœ… Bot is running in HYBRID ADAPTIVE MODE!")
    print("ğŸ’¾ Smart Cache enabled")
    print("ğŸš€ Burst Mode ready")
    print("ğŸ“Š Check /stats for metrics\n")

    telegram_app.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nâš ï¸ Bot stopped")
        stats.save()
    except Exception as e:
        print(f"âŒ Error: {e}")
        logger.exception("âŒ Fatal error")
        stats.save()
    finally:
        import asyncio
        asyncio.run(api_manager.close())
