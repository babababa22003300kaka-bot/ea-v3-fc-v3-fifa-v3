#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸš€ Smart Telegram Sender Bot - Adaptive Hybrid Monitoring
Bot: @snipe12_bot

Architecture:
- Adaptive Hybrid Monitoring with Smart Cache
- Strict ID Validation (account_id based)
- Temporary Burst Mode (60s aggressive polling on new accounts)
- Smart TTL (adaptive cache refresh based on activity)
- Fallback Mechanism (resilient to network errors)
"""

import asyncio
import json
import logging
import random
import re
from dataclasses import asdict, dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

import aiohttp
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Logging Configuration
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[
        logging.FileHandler("bot.log", encoding="utf-8"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ Load Configuration
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

with open("config.json", "r", encoding="utf-8") as f:
    CONFIG = json.load(f)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ Settings & State Management
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# CSRF Token caching
CSRF_TOKEN_TTL = 1200  # 20 minutes

# Smart Cache Settings
CACHE_TTL_MIN = 120      # 2 Ø¯Ù‚ÙŠÙ‚Ø© (Ø¹Ù†Ø¯ Ù†Ø´Ø§Ø· Ø¹Ø§Ù„ÙŠ)
CACHE_TTL_NORMAL = 300   # 5 Ø¯Ù‚Ø§Ø¦Ù‚ (Ø¹Ø§Ø¯ÙŠ)
CACHE_TTL_MAX = 600      # 10 Ø¯Ù‚Ø§Ø¦Ù‚ (Ø¹Ù†Ø¯ Ù‡Ø¯ÙˆØ¡)

# Burst Mode Settings
BURST_MODE_DURATION = 60  # Ù…Ø¯Ø© Ø§Ù„Ù€ Burst: 60 Ø«Ø§Ù†ÙŠØ©
BURST_MODE_INTERVAL = 2.5 # ÙØ§ØµÙ„ Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙÙŠ ÙˆØ¶Ø¹ Burst: 2.5 Ø«Ø§Ù†ÙŠØ©

# Background monitor intervals
POLLING_INTERVALS = {
    "LOGGING": (3.1, 5.2),
    "LOGGED": (10, 30),
    "LOGGED IN": (10, 30),
    "AVAILABLE": (10, 300),
    "ACTIVE": (10, 300),
    "CODE SENT": (5, 15),
    "AMOUNT TAKEN": (300, 600),
    "WRONG DETAILS": (900, 1800),
    "NEW ACCOUNT": (600, 1200),
    "DISABLED": (1800, 3600),
    "NO TRANSFER ACCESS": (300, 600),
    "BACKUP CODE WRONG": (180, 300),
    "TRANSFER LIST IS FULL": (120, 240),
    "NO CLUB": (600, 1200),
    "GENERAL LOGIN ERROR": (300, 600),
    "ERROR": (600, 1200),
    "BLOCKED": (1800, 3600),
    "WAITING": (30, 60),
    "DEFAULT": (60, 120),
}

# Status classification
TRANSITIONAL_STATUSES: Set[str] = {
    "LOGGING",
    "LOGGED",
    "LOGGED IN",
    "CODE SENT",
    "WAITING",
}

FINAL_STATUSES: Set[str] = {
    "AVAILABLE",
    "ACTIVE",
    "WRONG DETAILS",
    "BACKUP CODE WRONG",
    "NEW ACCOUNT",
    "DISABLED",
    "NO TRANSFER ACCESS",
    "TRANSFER LIST IS FULL",
    "NO CLUB",
    "GENERAL LOGIN ERROR",
    "ERROR",
    "BLOCKED",
    "AMOUNT TAKEN",
}

# Database files
MONITORED_ACCOUNTS_FILE = "monitored_accounts.json"
STATS_FILE = "request_stats.json"

# Global vars
telegram_app = None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š Statistics
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class RequestStats:
    """Track request statistics"""
    total_requests: int = 0
    csrf_refreshes: int = 0
    batch_fetches: int = 0
    cache_hits: int = 0
    errors: int = 0
    fast_detections: int = 0
    burst_activations: int = 0
    adaptive_adjustments: int = 0  # Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù€ TTL
    last_reset: str = datetime.now().isoformat()

    def save(self):
        try:
            with open(STATS_FILE, "w") as f:
                json.dump(asdict(self), f, indent=2)
        except Exception as e:
            logger.error(f"âŒ Error saving stats: {e}")

    @classmethod
    def load(cls):
        if Path(STATS_FILE).exists():
            try:
                with open(STATS_FILE, "r") as f:
                    data = json.load(f)
                return cls(**data)
            except:
                pass
        return cls()

stats = RequestStats.load()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§  Smart Cache Manager
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SmartCacheManager:
    """
    Ù…Ø¯ÙŠØ± Ø°Ø§ÙƒØ±Ø© Ù…Ø¤Ù‚ØªØ© Ø°ÙƒÙŠ Ù…Ø¹:
    - Smart TTL Ù…ØªÙƒÙŠÙ
    - Burst mode
    - Fallback mechanism
    """
    
    def __init__(self):
        self.cache: Optional[List[Dict]] = None
        self.cache_timestamp: Optional[datetime] = None
        self.cache_ttl: float = CACHE_TTL_NORMAL
        
        # Burst mode tracking
        self.burst_mode_active: bool = False
        self.burst_mode_started: Optional[datetime] = None
        
        # Activity tracking for Smart TTL
        self.last_changes_count: int = 0
        self.consecutive_quiet_cycles: int = 0
        
        # Fallback
        self.last_successful_cache: Optional[List[Dict]] = None
        self.last_successful_timestamp: Optional[datetime] = None
        
        # Accounts being monitored during burst
        self.burst_targets: Set[str] = set()  # account IDs in burst mode
    
    def is_cache_valid(self) -> bool:
        """ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù€ cache"""
        if self.cache is None or self.cache_timestamp is None:
            return False
        
        # ÙÙŠ ÙˆØ¶Ø¹ BurstØŒ Ø§Ù„Ù€ cache Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù…Ù†ØªÙ‡ÙŠ (Ù†Ø±ÙŠØ¯ ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙ…Ø±)
        if self.burst_mode_active:
            return False
        
        age = (datetime.now() - self.cache_timestamp).total_seconds()
        return age < self.cache_ttl
    
    def activate_burst_mode(self, account_id: str):
        """ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Burst Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹ÙŠÙ†"""
        global stats
        
        if not self.burst_mode_active:
            self.burst_mode_active = True
            self.burst_mode_started = datetime.now()
            stats.burst_activations += 1
            logger.info(f"ğŸš€ BURST MODE ACTIVATED for account {account_id}")
        
        self.burst_targets.add(account_id)
    
    def check_burst_mode(self):
        """ØªØ­Ù‚Ù‚ ÙˆØ¥Ù„ØºØ§Ø¡ ÙˆØ¶Ø¹ Burst Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Ù‰"""
        if not self.burst_mode_active:
            return
        
        elapsed = (datetime.now() - self.burst_mode_started).total_seconds()
        
        if elapsed >= BURST_MODE_DURATION:
            self.burst_mode_active = False
            self.burst_mode_started = None
            self.burst_targets.clear()
            logger.info(f"âš¡ BURST MODE DEACTIVATED (lasted {elapsed:.1f}s)")
    
    def adjust_ttl(self, changes_detected: int):
        """
        ØªØ¹Ø¯ÙŠÙ„ Ø°ÙƒÙŠ Ù„Ù€ TTL Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø´Ø§Ø·
        
        - ÙƒØ«ÙŠØ± ØªØºÙŠÙŠØ±Ø§Øª â†’ TTL Ù‚ØµÙŠØ± (Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø£Ø³Ø±Ø¹)
        - Ù‚Ù„ÙŠÙ„ ØªØºÙŠÙŠØ±Ø§Øª â†’ TTL Ø·ÙˆÙŠÙ„ (ØªÙˆÙÙŠØ± Ù…ÙˆØ§Ø±Ø¯)
        """
        global stats
        
        old_ttl = self.cache_ttl
        
        if changes_detected >= 5:
            # Ù†Ø´Ø§Ø· Ø¹Ø§Ù„ÙŠ Ø¬Ø¯Ø§Ù‹
            self.cache_ttl = CACHE_TTL_MIN
            self.consecutive_quiet_cycles = 0
            
        elif changes_detected >= 2:
            # Ù†Ø´Ø§Ø· Ù…ØªÙˆØ³Ø·
            self.cache_ttl = CACHE_TTL_NORMAL
            self.consecutive_quiet_cycles = 0
            
        else:
            # Ù‡Ø¯ÙˆØ¡
            self.consecutive_quiet_cycles += 1
            
            if self.consecutive_quiet_cycles >= 3:
                # 3 Ø¯ÙˆØ±Ø§Øª Ù‡Ø§Ø¯Ø¦Ø© Ù…ØªØªØ§Ù„ÙŠØ© â†’ Ù†Ø·ÙˆÙ„ Ø§Ù„ÙØªØ±Ø©
                self.cache_ttl = CACHE_TTL_MAX
        
        if old_ttl != self.cache_ttl:
            stats.adaptive_adjustments += 1
            logger.info(f"ğŸ¯ TTL adjusted: {old_ttl:.0f}s â†’ {self.cache_ttl:.0f}s (changes={changes_detected})")
    
    def update_cache(self, new_data: List[Dict], success: bool = True):
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ cache"""
        if success:
            self.cache = new_data
            self.cache_timestamp = datetime.now()
            self.last_successful_cache = new_data
            self.last_successful_timestamp = datetime.now()
        else:
            # ÙØ´Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ« - Ù†Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø± Ù†Ø³Ø®Ø© Ù†Ø§Ø¬Ø­Ø©
            logger.warning("âš ï¸ Cache update failed, using last successful cache")
            if self.last_successful_cache:
                self.cache = self.last_successful_cache
                self.cache_timestamp = self.last_successful_timestamp
    
    def get_cache(self) -> Optional[List[Dict]]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ cache"""
        return self.cache
    
    def get_account_by_id(self, account_id: str) -> Optional[Dict]:
        """
        ğŸ¯ Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ù€ ID (Ø£ÙƒØ«Ø± Ø£Ù…Ø§Ù†Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„)
        """
        if not self.cache:
            return None
        
        for account in self.cache:
            if str(account.get("idAccount", "")) == str(account_id):
                return account
        
        return None
    
    def get_account_by_email(self, email: str) -> Optional[Dict]:
        """Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ (Ù„Ù„Ø¨Ø­Ø« Ø§Ù„Ø£ÙˆÙ„ÙŠ)"""
        if not self.cache:
            return None
        
        email = email.lower().strip()
        for account in self.cache:
            if account.get("Sender", "").lower() == email:
                return account
        
        return None

# Global smart cache
smart_cache = SmartCacheManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ” Optimized API Manager
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OptimizedAPIManager:
    """API manager with smart cache integration"""

    def __init__(self):
        self.base_url = CONFIG["website"]["urls"]["base"]
        self.cookies = CONFIG["website"]["cookies"]

        # CSRF Token cache
        self.csrf_token = None
        self.csrf_expires_at = None

        # aiohttp session
        self.session = None

    async def initialize(self):
        """Initialize API manager"""
        await self._ensure_session()
        logger.info("ğŸš€ API Manager initialized (Hybrid Mode)")

    async def _ensure_session(self):
        """Ensure aiohttp session exists"""
        if self.session is None or self.session.closed:
            connector = aiohttp.TCPConnector(limit=10, limit_per_host=5)
            timeout = aiohttp.ClientTimeout(total=30)

            self.session = aiohttp.ClientSession(
                connector=connector, timeout=timeout, cookies=self.cookies
            )

    async def _send_status_notification(
        self,
        email: str,
        account_id: str,
        old_status: str,
        new_status: str,
        chat_id: int,
        account_data: Dict,
    ):
        """Send status change notification"""
        try:
            old_emoji = get_status_emoji(old_status)
            new_emoji = get_status_emoji(new_status)

            old_status_ar = get_status_description_ar(old_status)
            new_status_ar = get_status_description_ar(new_status)

            notification = (
                f"ğŸ”” *ØªÙ†Ø¨ÙŠÙ‡ ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©!*\n\n"
                f"ğŸ“§ Ø§Ù„Ø¨Ø±ÙŠØ¯: `{email}`\n"
                f"ğŸ†” ID: `{account_id}`\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©:*\n"
                f"   `{old_status}`\n"
                f"   {old_emoji} {old_status_ar}\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:*\n"
                f"   `{new_status}`\n"
                f"   {new_emoji} {new_status_ar}\n\n"
                f"ğŸ• Ø§Ù„ÙˆÙ‚Øª: {datetime.now().strftime('%H:%M:%S')}\n"
            )

            available = format_number(account_data.get("Available", "0"))
            taken = format_number(account_data.get("Taken", "0"))

            if available != "0" or taken != "0":
                notification += f"\nğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {available}\nâœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {taken}\n"

            notification += f"\nğŸ’¡ `/search {email}` Ù„Ù„ØªÙØ§ØµÙŠÙ„"

            await telegram_app.bot.send_message(
                chat_id=chat_id, text=notification, parse_mode="Markdown"
            )

        except Exception as e:
            logger.error(f"âŒ Failed to send notification: {e}")

    async def get_csrf_token(self, force_refresh: bool = False) -> Optional[str]:
        """Get CSRF token with caching"""
        global stats

        if not force_refresh and self.csrf_token and self.csrf_expires_at:
            if datetime.now() < self.csrf_expires_at:
                stats.cache_hits += 1
                return self.csrf_token

        logger.info("ğŸ”„ Fetching CSRF token...")
        stats.csrf_refreshes += 1
        stats.total_requests += 1

        await self._ensure_session()

        try:
            async with self.session.get(f"{self.base_url}/senderPage") as response:
                if response.status == 200:
                    html = await response.text()
                    match = re.search(
                        r'<meta name="csrf-token" content="([^"]+)"', html
                    )
                    if match:
                        self.csrf_token = match.group(1)
                        self.csrf_expires_at = datetime.now() + timedelta(
                            seconds=CSRF_TOKEN_TTL
                        )
                        logger.info(f"âœ… CSRF cached ({CSRF_TOKEN_TTL}s)")
                        return self.csrf_token
        except Exception as e:
            logger.error(f"âŒ CSRF fetch error: {e}")
            stats.errors += 1

        return None

    async def fetch_all_accounts_batch(self, force_refresh: bool = False) -> List[Dict]:
        """
        ğŸ¯ Ø¬Ù„Ø¨ Ù…Ø±ÙƒØ²ÙŠ Ù„Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ø¹ Smart Cache
        """
        global stats

        # ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù€ cache
        if not force_refresh and smart_cache.is_cache_valid():
            stats.cache_hits += 1
            cached = smart_cache.get_cache()
            if cached:
                return cached

        logger.info("ğŸ”„ Batch fetch...")
        stats.batch_fetches += 1
        stats.total_requests += 1

        csrf = await self.get_csrf_token()
        if not csrf:
            # Ø§Ø³ØªØ®Ø¯Ø§Ù… Fallback
            smart_cache.update_cache([], success=False)
            return smart_cache.get_cache() or []

        await self._ensure_session()

        try:
            payload = {"date": "0", "bigUpdate": "0", "csrf_token": csrf}

            async with self.session.post(
                f"{self.base_url}/dataFunctions/updateSenderPage", data=payload
            ) as response:

                if response.status == 200:
                    data = await response.json()

                    if "data" in data:
                        accounts = data["data"]

                        INDEX_MAP = {
                            "idAccount": 0,
                            "image": 1,
                            "Sender": 2,
                            "Start": 3,
                            "Last Update": 4,
                            "Taken": 5,
                            "Status": 6,
                            "Available": 7,
                            "password": 8,
                            "backupCodes": 9,
                            "Group": 10,
                            "groupNameId": 11,
                            "Take": 12,
                            "Keep": 13,
                        }

                        parsed = []
                        for account in accounts:
                            if len(account) > INDEX_MAP["Sender"]:
                                acc = {}
                                for key, idx in INDEX_MAP.items():
                                    acc[key] = (
                                        str(account[idx])
                                        if idx < len(account) and account[idx]
                                        else ""
                                    )
                                parsed.append(acc)

                        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ cache
                        smart_cache.update_cache(parsed, success=True)

                        logger.info(f"âœ… Fetched {len(parsed)} accounts (TTL={smart_cache.cache_ttl:.0f}s)")
                        return parsed

                elif response.status in [403, 419]:
                    self.csrf_token = None
                    return await self.fetch_all_accounts_batch(force_refresh=True)

        except Exception as e:
            logger.error(f"âŒ Batch fetch error: {e}")
            stats.errors += 1
            # Ø§Ø³ØªØ®Ø¯Ø§Ù… Fallback
            smart_cache.update_cache([], success=False)

        return smart_cache.get_cache() or []

    async def search_sender_by_id(self, account_id: str) -> Optional[Dict]:
        """
        ğŸ¯ Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ù€ ID (Ø£ÙƒØ«Ø± Ø£Ù…Ø§Ù†Ø§Ù‹)
        """
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ cache Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        if not smart_cache.is_cache_valid():
            await self.fetch_all_accounts_batch()
        
        return smart_cache.get_account_by_id(account_id)

    async def search_sender_by_email(self, email: str) -> Optional[Dict]:
        """Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„"""
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ cache Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        if not smart_cache.is_cache_valid():
            await self.fetch_all_accounts_batch()
        
        return smart_cache.get_account_by_email(email)

    async def add_sender(
        self,
        email: str,
        password: str,
        backup_codes: str = "",
        amount_take: str = "",
        amount_keep: str = "",
    ) -> Tuple[bool, str]:
        """Add sender"""
        global stats

        csrf = await self.get_csrf_token()
        if not csrf:
            return False, "No CSRF"

        stats.total_requests += 1
        await self._ensure_session()

        defaults = CONFIG["website"]["defaults"]
        payload = {
            "email": email,
            "password": password,
            "backupCodes": backup_codes,
            "groupName": defaults["group_name"],
            "accountLock": defaults["account_lock"],
            "amountToTake": amount_take or defaults.get("amount_take", ""),
            "amountToKeep": amount_keep or defaults.get("amount_keep", ""),
            "priority": defaults.get("priority", ""),
            "forceProxy": defaults.get("force_proxy", ""),
            "userPrice": defaults.get("user_price", ""),
            "csrf_token": csrf,
        }

        try:
            async with self.session.post(
                f"{self.base_url}/dataFunctions/addAccount", json=payload
            ) as response:

                if response.status == 200:
                    try:
                        data = await response.json()
                        if "success" in data:
                            # Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù€ cache Ù„Ø¥Ø¬Ø¨Ø§Ø± ØªØ­Ø¯ÙŠØ«
                            smart_cache.cache = None
                            smart_cache.cache_timestamp = None
                            return True, data.get("success", "Success")
                        elif "error" in data:
                            error = data.get("error", "")
                            if "already" in error.lower():
                                return True, "Exists"
                            return False, error
                    except:
                        text = await response.text()
                        if "success" in text.lower():
                            smart_cache.cache = None
                            smart_cache.cache_timestamp = None
                            return True, "Success"
                        return False, text[:100]

                elif response.status in [403, 419]:
                    self.csrf_token = None
                    return False, "CSRF expired"

                return False, f"Status {response.status}"

        except Exception as e:
            stats.errors += 1
            return False, str(e)

    async def close(self):
        """Cleanup"""
        if self.session and not self.session.closed:
            await self.session.close()

# Global API manager
api_manager = OptimizedAPIManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¾ Database Functions with ID Validation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def load_monitored_accounts() -> Dict:
    if Path(MONITORED_ACCOUNTS_FILE).exists():
        try:
            with open(MONITORED_ACCOUNTS_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except:
            pass
    return {}

def save_monitored_accounts(accounts: Dict):
    try:
        with open(MONITORED_ACCOUNTS_FILE, "w", encoding="utf-8") as f:
            json.dump(accounts, f, indent=2, ensure_ascii=False)
    except Exception as e:
        logger.error(f"âŒ Save error: {e}")

def add_monitored_account(email: str, account_id: str, status: str, chat_id: int):
    """
    ğŸ¯ Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø¹ ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù€ ID Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚
    """
    accounts = load_monitored_accounts()
    
    # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ ID ÙƒÙ€ key Ø±Ø¦ÙŠØ³ÙŠ (Ø£ÙƒØ«Ø± Ø£Ù…Ø§Ù†Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„)
    key = f"{account_id}_{email}"  # Ù…ÙØªØ§Ø­ ÙØ±ÙŠØ¯
    
    accounts[key] = {
        "email": email,
        "account_id": account_id,  # ğŸ¯ Ø§Ù„Ù‡ÙˆÙŠØ© Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
        "last_known_status": status,
        "chat_id": chat_id,
        "added_at": datetime.now().isoformat(),
        "last_check": datetime.now().isoformat(),
    }
    save_monitored_accounts(accounts)
    
    logger.info(f"âœ… Account added to monitoring: {email} (ID: {account_id})")

def update_monitored_account_status(account_id: str, new_status: str):
    """
    ğŸ¯ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ ID
    """
    accounts = load_monitored_accounts()
    
    # Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ù€ ID
    for key, data in accounts.items():
        if data.get("account_id") == account_id:
            data["last_known_status"] = new_status
            data["last_check"] = datetime.now().isoformat()
            save_monitored_accounts(accounts)
            return
    
    logger.warning(f"âš ï¸ Account ID {account_id} not found in monitoring list")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ Helper Functions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def is_admin(user_id: int) -> bool:
    admin_ids = CONFIG["telegram"].get("admin_ids", [])
    return not admin_ids or user_id in admin_ids

def get_adaptive_interval(status: str) -> float:
    interval_range = POLLING_INTERVALS.get(status.upper(), POLLING_INTERVALS["DEFAULT"])
    return round(random.uniform(*interval_range), 2)

def format_number(value) -> str:
    if value is None or value == "" or value == "null":
        return "0"

    try:
        value_str = str(value).strip()
        if not value_str.replace(".", "", 1).replace("-", "", 1).isdigit():
            return value_str

        num = float(value_str)

        if abs(num) < 1000:
            return str(int(num)) if num == int(num) else str(num)

        k_value = num / 1000

        if abs(k_value) >= 1000:
            return f"{k_value:,.0f}k"
        else:
            return f"{int(k_value)}k"
    except:
        return str(value)

def get_status_emoji(status: str) -> str:
    emoji_map = {
        "LOGGING": "ğŸ”„",
        "LOGGED": "âœ…",
        "LOGGED IN": "ğŸ‘¤",
        "ACTIVE": "âœ…",
        "AVAILABLE": "ğŸ’°",
        "CODE SENT": "ğŸ“§",
        "AMOUNT TAKEN": "ğŸ’¸",
        "WRONG DETAILS": "âš ï¸",
        "NEW ACCOUNT": "ğŸ†•",
        "DISABLED": "ğŸ”’",
        "NO TRANSFER ACCESS": "ğŸš«",
        "BACKUP CODE WRONG": "ğŸ”‘",
        "TRANSFER LIST IS FULL": "ğŸ“¦",
        "NO CLUB": "â›”",
        "GENERAL LOGIN ERROR": "â—",
        "ERROR": "âŒ",
        "WAITING": "â³",
        "BLOCKED": "ğŸš«",
    }
    return emoji_map.get(status.upper(), "ğŸ“Š")

def get_status_description_ar(status: str) -> str:
    descriptions = {
        "LOGGING": "Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        "LOGGED": "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        "LOGGED IN": "Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¯Ø®Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨",
        "ACTIVE": "Ù†Ø´Ø·",
        "AVAILABLE": "Ù…ØªØ§Ø­ - Ø§Ù„Ø­Ø³Ø§Ø¨ ØªÙ…Ø§Ù… ÙˆØ¬Ø§Ù‡Ø² Ù„Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª",
        "CODE SENT": "Ø§Ù„ÙƒÙˆØ¯ Ø§ØªØ¨Ø¹Øª",
        "AMOUNT TAKEN": "Ø§Ù„ÙÙ„ÙˆØ³ (Ø§Ù„ÙƒÙˆÙŠÙ†Ø²) Ø§ØªØ£Ø®Ø¯Øª ÙˆØ§Ù„ÙƒÙˆÙŠÙ†Ø² Ø§ØªÙ†Ù‚Ù„Øª",
        "WRONG DETAILS": "Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙ„Ø· - Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ø£Ùˆ Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯ Ø£Ùˆ Ø§Ù„Ù€ EA Account Ù…Ø´ ØµØ­",
        "NEW ACCOUNT": "Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯ - Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯ ÙˆÙ…Ø§ ÙÙŠÙ‡ÙˆØ´ Ù„Ø§Ø¹ÙŠØ¨Ø© ÙƒÙØ§ÙŠØ©",
        "DISABLED": "Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø·Ù„",
        "NO TRANSFER ACCESS": "Ù…Ø§Ø±ÙƒØª Ù…Ù‚ÙÙˆÙ„ - ÙˆÙŠØ¨ Ø§Ø¨ Ù…Ù‚ÙÙˆÙ„ - Companion Ù…Ù‚ÙÙˆÙ„",
        "BACKUP CODE WRONG": "Ø§ÙƒÙˆØ§Ø¯ ØºÙ„Ø· - Ø¬Ø¯Ø¯ Ø§ÙƒÙˆØ§Ø¯ ÙˆØ§Ø¨Ø¹ØªÙ‡Ù… ØªØ§Ù†ÙŠ",
        "TRANSFER LIST IS FULL": "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª ÙƒØ§Ù…Ù„Ø© - ÙØ¶ÙŠ Ù…Ø§Ø±ÙƒØª Ø´ÙˆÙŠØ© ÙˆØ§Ø¨Ø¹Øª (Ù„Ø§Ø¹ÙŠØ¨Ø©)",
        "NO CLUB": "Ù…Ø§ ÙÙŠØ´ ÙƒÙ„ÙˆØ¨",
        "GENERAL LOGIN ERROR": "Ù…Ø´ÙƒÙ„Ø© Ø¹Ø§Ù…Ø© ÙÙŠ Ø§Ù„Ø¯Ø®ÙˆÙ„ - Ø®Ø·Ø£ Ø¹Ø´ÙˆØ§Ø¦ÙŠ ÙÙŠ Ø§Ù„Ù„ÙˆØ¬ Ø¥Ù†",
        "ERROR": "Ø®Ø·Ø£ Ø¹Ø§Ù…",
        "WAITING": "Ù…Ù†ØªØ¸Ø±",
        "BLOCKED": "Ù…Ø­Ø¸ÙˆØ±",
    }
    return descriptions.get(status.upper(), status)

def parse_sender_data(text: str) -> Dict:
    lines = text.strip().split("\n")
    data = {
        "email": "",
        "password": "",
        "codes": [],
        "amount_take": "",
        "amount_keep": "",
    }

    email_pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"

    for line in lines:
        line = line.strip()
        if not line:
            continue

        if re.match(email_pattern, line):
            data["email"] = line.lower()
        elif "Ø§Ø³Ø­Ø¨" in line:
            match = re.search(r"Ø§Ø³Ø­Ø¨\s*(\d+)", line)
            if match:
                data["amount_take"] = match.group(1)
        elif "ÙŠØ³ÙŠØ¨" in line:
            match = re.search(r"ÙŠØ³ÙŠØ¨\s*(\d+)", line)
            if match:
                data["amount_keep"] = match.group(1)
        elif re.match(r"^[\d.]+$", line):
            clean_code = line.split(".")[-1] if "." in line else line
            data["codes"].append(clean_code)
        elif data["email"] and not data["password"]:
            data["password"] = line

    data["codes"] = ",".join(data["codes"])
    return data

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Burst Mode Initial Monitoring
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def wait_for_status_change(
    email: str, message_obj, chat_id: int
) -> Tuple[bool, Optional[Dict]]:
    """
    ğŸš€ Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø¹ Burst Mode Ø§Ù„Ù…Ø¤Ù‚Øª
    
    Ø¹Ù†Ø¯ Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯:
    1. ØªÙØ¹ÙŠÙ„ Burst Mode (ØªØ­Ø¯ÙŠØ« cache ÙƒÙ„ 2.5 Ø«Ø§Ù†ÙŠØ©)
    2. Ù…Ø±Ø§Ù‚Ø¨Ø© Ø³Ø±ÙŠØ¹Ø© Ø¬Ø¯Ø§Ù‹ Ù„Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯
    3. Ø¥Ù„ØºØ§Ø¡ Burst Ø¨Ø¹Ø¯ 60 Ø«Ø§Ù†ÙŠØ© Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ø­Ø§Ù„Ø© Ù†Ù‡Ø§Ø¦ÙŠØ©
    """
    
    global stats
    
    await asyncio.sleep(1.0)
    
    start_time = datetime.now()
    total_elapsed = 0
    last_status = None
    status_changes = []
    stable_count = 0
    account_id = None
    
    # ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø£ÙˆÙ„ Ù…Ø±Ø© ÙˆØ§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ ID
    logger.info(f"ğŸ” Looking for new account: {email}")
    
    for initial_attempt in range(1, 15):  # 15 Ù…Ø­Ø§ÙˆÙ„Ø© = ~45 Ø«Ø§Ù†ÙŠØ©
        account_info = await api_manager.search_sender_by_email(email)
        
        if account_info:
            account_id = account_info.get("idAccount")
            if account_id:
                logger.info(f"âœ… Found account: {email} (ID: {account_id})")
                
                # ğŸš€ ØªÙØ¹ÙŠÙ„ Burst Mode Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨
                smart_cache.activate_burst_mode(account_id)
                
                break
        
        await message_obj.edit_text(
            f"ğŸ” *Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø£ÙˆÙ„ÙŠ Ø¹Ù† Ø§Ù„Ø­Ø³Ø§Ø¨*\n\n"
            f"ğŸ“§ `{email}`\n"
            f"ğŸ”„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©: {initial_attempt}/15\n"
            f"â±ï¸ ~{total_elapsed:.0f}s",
            parse_mode="Markdown",
        )
        
        interval = 3.0
        total_elapsed += interval
        await asyncio.sleep(interval)
    
    if not account_id:
        return False, None
    
    # ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ© 2: Ù…Ø±Ø§Ù‚Ø¨Ø© Ø³Ø±ÙŠØ¹Ø© Ù…Ø¹ Burst Mode
    logger.info(f"ğŸš€ Starting burst monitoring for {email} (ID: {account_id})")
    
    max_attempts = 40  # 40 Ù…Ø­Ø§ÙˆÙ„Ø© * 2.5 Ø«Ø§Ù†ÙŠØ© = 100 Ø«Ø§Ù†ÙŠØ© max
    
    for attempt in range(1, max_attempts + 1):
        try:
            # ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Burst Mode
            smart_cache.check_burst_mode()
            
            mode_indicator = "ğŸš€ BURST" if smart_cache.burst_mode_active else "ğŸ”„ NORMAL"
            
            # ğŸ¯ Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ù€ ID (Ø£ÙƒØ«Ø± Ø£Ù…Ø§Ù†Ø§Ù‹)
            account_info = await api_manager.search_sender_by_id(account_id)
            
            if not account_info:
                logger.warning(f"âš ï¸ Account ID {account_id} disappeared!")
                await asyncio.sleep(2.0)
                continue
            
            status = account_info.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯").upper()
            
            # ØªØªØ¨Ø¹ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
            if status != last_status:
                change_time = (datetime.now() - start_time).total_seconds()
                logger.info(f"ğŸ“Š {email} status: {status} ({change_time:.1f}s)")
                
                status_changes.append({
                    "status": status,
                    "time": datetime.now(),
                    "elapsed": total_elapsed
                })
                
                if last_status and status in FINAL_STATUSES:
                    stats.fast_detections += 1
                    logger.info(f"âš¡ FAST: {last_status} â†’ {status} in {change_time:.1f}s")
                
                last_status = status
                stable_count = 0
            else:
                stable_count += 1
            
            # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø­Ø§Ù„Ø©
            is_final = status in FINAL_STATUSES
            is_transitional = status in TRANSITIONAL_STATUSES
            
            status_ar = get_status_description_ar(status)
            status_type = "âœ… Ù†Ù‡Ø§Ø¦ÙŠØ©" if is_final else "â³ Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ©" if is_transitional else "â“ ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©"
            
            # Ø¹Ø±Ø¶ Ø³Ø¬Ù„ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
            changes_text = ""
            if len(status_changes) > 1:
                changes_text = "\nğŸ“ *Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª:*\n"
                for i, change in enumerate(status_changes[-3:]):
                    changes_text += f"   {i+1}. `{change['status']}` ({change['elapsed']:.0f}s)\n"
            
            # Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ«
            await message_obj.edit_text(
                f"{mode_indicator} *Ù…Ø±Ø§Ù‚Ø¨Ø© Ø°ÙƒÙŠØ©*\n\n"
                f"ğŸ“§ `{email}`\n"
                f"ğŸ†” ID: `{account_id}`\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø©:* `{status}`\n"
                f"   {get_status_emoji(status)} {status_ar}\n\n"
                f"ğŸ¯ Ø§Ù„Ù†ÙˆØ¹: {status_type}\n"
                f"ğŸ”„ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±: {stable_count}/2\n"
                f"{changes_text}\n"
                f"â±ï¸ Ø§Ù„ÙˆÙ‚Øª: {int(total_elapsed)}s\n"
                f"ğŸ” Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©: {attempt}/{max_attempts}",
                parse_mode="Markdown",
            )
            
            # Ù…Ù†Ø·Ù‚ Ø§Ù„ØªÙˆÙ‚Ù
            if is_final and stable_count >= 2:
                response_time = (datetime.now() - start_time).total_seconds()
                logger.info(f"âœ… {email} STABLE at {status} in {response_time:.1f}s")
                
                # Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©
                if status in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
                    add_monitored_account(email, account_id, status, chat_id)
                
                # Ø¥Ù„ØºØ§Ø¡ Burst Mode
                smart_cache.burst_mode_active = False
                smart_cache.burst_targets.discard(account_id)
                
                return True, account_info
            
            # ÙØ§ØµÙ„ Ø²Ù…Ù†ÙŠ
            if smart_cache.burst_mode_active:
                interval = BURST_MODE_INTERVAL
            else:
                interval = 4.0 if is_transitional else 5.0
            
            total_elapsed += interval
            await asyncio.sleep(interval)
            
        except Exception as e:
            logger.exception(f"âŒ Monitoring error #{attempt}: {e}")
            await asyncio.sleep(2.0)
            total_elapsed += 2.0
    
    # Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª
    logger.warning(f"â±ï¸ {email}: Timeout, final status: {last_status}")
    
    # Ø¥Ù„ØºØ§Ø¡ Burst Mode
    smart_cache.burst_mode_active = False
    if account_id:
        smart_cache.burst_targets.discard(account_id)
    
    if account_info:
        status = account_info.get("Status", "").upper()
        if status in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
            add_monitored_account(email, account_id, status, chat_id)
        return True, account_info
    
    return False, None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ Background Monitor with Smart TTL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def continuous_monitor():
    """
    ğŸ¯ Ù…Ø±Ø§Ù‚Ø¨ Ù…Ø³ØªÙ…Ø± Ù…Ø¹ Smart TTL
    """
    
    logger.info("ğŸ”„ Background monitor started (Smart TTL)")

    while True:
        try:
            accounts = load_monitored_accounts()

            if not accounts:
                await asyncio.sleep(30)
                continue

            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ cache
            all_accounts = await api_manager.fetch_all_accounts_batch()
            
            # Ø¨Ù†Ø§Ø¡ dictionary Ø¨Ø§Ù„Ù€ ID Ù„Ù„Ø¨Ø­Ø« Ø§Ù„Ø£Ø³Ø±Ø¹
            accounts_by_id = {
                acc.get("idAccount"): acc
                for acc in all_accounts
                if acc.get("idAccount")
            }

            changes_detected = 0

            for key, data in list(accounts.items()):
                try:
                    account_id = data.get("account_id")
                    if not account_id:
                        continue
                    
                    # ğŸ¯ Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ù€ ID (Ø£ÙƒØ«Ø± Ø£Ù…Ø§Ù†Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„)
                    account_info = accounts_by_id.get(account_id)

                    if not account_info:
                        logger.warning(f"âš ï¸ Account ID {account_id} not found in batch")
                        continue

                    current_status = account_info.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯").upper()
                    last_status = data["last_known_status"].upper()

                    if current_status != last_status:
                        changes_detected += 1
                        email = data.get("email", "unknown")
                        
                        logger.info(f"ğŸ”” {email}: {last_status} â†’ {current_status}")

                        if current_status in ["BACKUP CODE WRONG", "WRONG DETAILS"]:
                            logger.warning(f"âš ï¸ {email} needs attention: {current_status}")
                        elif current_status == "TRANSFER LIST IS FULL":
                            logger.info(f"ğŸ“¦ {email} transfer list full")
                        elif current_status == "AMOUNT TAKEN":
                            logger.info(f"ğŸ’¸ {email} amount taken")

                        update_monitored_account_status(account_id, current_status)

                        await api_manager._send_status_notification(
                            email,
                            account_id,
                            last_status,
                            current_status,
                            data["chat_id"],
                            account_info,
                        )
                    else:
                        update_monitored_account_status(account_id, current_status)

                except Exception as e:
                    logger.exception(f"âŒ Error checking account")

            # ğŸ¯ ØªØ¹Ø¯ÙŠÙ„ Ø°ÙƒÙŠ Ù„Ù„Ù€ TTL Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø´Ø§Ø·
            smart_cache.adjust_ttl(changes_detected)
            
            # ÙØªØ±Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
            statuses = [d["last_known_status"] for d in accounts.values()]

            if "LOGGING" in statuses:
                cycle_delay = random.uniform(10, 20)
            elif "AVAILABLE" in statuses or "ACTIVE" in statuses:
                cycle_delay = random.uniform(30, 60)
            else:
                cycle_delay = random.uniform(60, 120)

            logger.debug(f"ğŸ’¤ Next check in {cycle_delay:.1f}s (TTL={smart_cache.cache_ttl:.0f}s, changes={changes_detected})")
            await asyncio.sleep(cycle_delay)

        except Exception as e:
            logger.exception("âŒ Monitor error")
            await asyncio.sleep(30)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ Bot Commands
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command"""
    user = update.effective_user

    if not is_admin(user.id):
        await update.message.reply_text("âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†.")
        return

    welcome_msg = (
        f"Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.first_name}! ğŸ‘‹\n\n"
        "ğŸš€ *Ø¨ÙˆØª Ø§Ù„Ø³ÙŠÙ†Ø¯Ø±Ø² Ø§Ù„Ù…ØªØ·ÙˆØ±*\n"
        "ğŸ§  *Adaptive Hybrid Monitoring*\n\n"
        "*ğŸ“ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¥Ø¶Ø§ÙØ©:*\n"
        "```\n"
        "email@gmail.com\n"
        "password123\n"
        "12345678\n"
        "Ø§Ø³Ø­Ø¨ 100\n"
        "ÙŠØ³ÙŠØ¨ 50\n"
        "```\n\n"
        "*âœ¨ Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©:*\n"
        "â€¢ ğŸ¯ Strict ID Validation\n"
        "â€¢ ğŸš€ Temporary Burst Mode (60s)\n"
        "â€¢ ğŸ§  Smart TTL (2-10 Ø¯Ù‚ÙŠÙ‚Ø©)\n"
        "â€¢ ğŸ”„ Fallback Mechanism\n"
        "â€¢ ğŸŒ Bilingual Display\n\n"
        "*â±ï¸ Ø²Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©: 3-10 Ø«ÙˆØ§Ù†Ù*\n\n"
        "*ğŸ” Ø§Ù„Ø£ÙˆØ§Ù…Ø±:*\n"
        "`/search email@gmail.com`\n"
        "`/monitored` - Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©\n"
        "`/stats` - Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª\n"
        "`/status` - Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…"
    )

    await update.message.reply_text(welcome_msg, parse_mode="Markdown")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle adding senders"""

    if not is_admin(update.effective_user.id):
        return

    if update.message.text.startswith("/"):
        return

    data = parse_sender_data(update.message.text)

    if not data["email"] or not data["password"]:
        await update.message.reply_text("âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©!")
        return

    msg = await update.message.reply_text(
        f"â³ *Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø¶Ø§ÙØ©...*\nğŸ“§ `{data['email']}`", parse_mode="Markdown"
    )

    try:
        success, message = await api_manager.add_sender(
            email=data["email"],
            password=data["password"],
            backup_codes=data["codes"],
            amount_take=data["amount_take"],
            amount_keep=data["amount_keep"],
        )

        if success:
            await msg.edit_text(
                f"âœ… *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©!*\n"
                f"ğŸ“§ `{data['email']}`\n\n"
                f"ğŸš€ *ØªÙØ¹ÙŠÙ„ BURST MODE...*\n"
                f"â±ï¸ Ù…ØªÙˆÙ‚Ø¹: 3-10 Ø«ÙˆØ§Ù†Ù",
                parse_mode="Markdown",
            )

            monitoring_success, account_info = await wait_for_status_change(
                data["email"], msg, update.effective_chat.id
            )

            if account_info:
                status = account_info.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
                status_ar = get_status_description_ar(status)
                account_id = account_info.get("idAccount", "N/A")

                result_text = (
                    f"âœ… *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø¨Ù†Ø¬Ø§Ø­!*\n\n"
                    f"ğŸ“§ `{data['email']}`\n"
                    f"ğŸ†” ID: `{account_id}`\n\n"
                    f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:*\n"
                    f"   `{status}`\n"
                    f"   {get_status_emoji(status)} {status_ar}\n\n"
                )

                if status.upper() in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
                    result_text += f"ğŸ”„ *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©!*\n"
                elif status.upper() in ["WRONG DETAILS", "BACKUP CODE WRONG"]:
                    result_text += f"âš ï¸ *ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø©!*\n"

                available = format_number(account_info.get("Available", "0"))
                taken = format_number(account_info.get("Taken", "0"))

                if available != "0" or taken != "0":
                    result_text += f"\nğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {available}\nâœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {taken}"

                await msg.edit_text(result_text, parse_mode="Markdown")

        else:
            await msg.edit_text(
                f"âŒ *ÙØ´Ù„Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©*\nğŸ“§ `{data['email']}`\nâš ï¸ {message}",
                parse_mode="Markdown",
            )

    except Exception as e:
        logger.exception(f"âŒ Error: {data['email']}")
        await msg.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Search sender"""

    if not is_admin(update.effective_user.id):
        return

    if not context.args:
        await update.message.reply_text(
            "ğŸ“ `/search email@example.com`", parse_mode="Markdown"
        )
        return

    email = context.args[0].strip().lower()
    msg = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...")

    try:
        result = await api_manager.search_sender_by_email(email)

        if result:
            status = result.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
            status_ar = get_status_description_ar(status)
            account_id = result.get("idAccount", "N/A")

            status_type = "Ù†Ù‡Ø§Ø¦ÙŠØ© âœ…" if status in FINAL_STATUSES else "Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ© â³" if status in TRANSITIONAL_STATUSES else "ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø© â“"

            text = (
                f"âœ… *ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ±*\n\n"
                f"ğŸ“§ `{result.get('Sender', email)}`\n"
                f"ğŸ†” ID: `{account_id}`\n"
                f"ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: {result.get('Group', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø©:* `{status}`\n"
                f"   {get_status_emoji(status)} {status_ar}\n"
                f"   ğŸ¯ Ø§Ù„Ù†ÙˆØ¹: {status_type}\n\n"
                f"ğŸ“… Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©: {format_number(result.get('Start', '0'))}\n"
                f"ğŸ• Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {result.get('Last Update', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}\n"
                f"ğŸ’° Ø§Ø³Ø­Ø¨: {format_number(result.get('Take', '0'))}\n"
                f"ğŸ’¸ ÙŠØ³ÙŠØ¨: {format_number(result.get('Keep', '0'))}\n"
                f"âœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {format_number(result.get('Taken', '0'))}\n"
                f"ğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {format_number(result.get('Available', '0'))}"
            )

            accounts = load_monitored_accounts()
            # ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ù€ ID
            is_monitored = any(d.get("account_id") == account_id for d in accounts.values())
            
            if is_monitored:
                text += f"\n\nğŸ”„ *Ù…Ø±Ø§Ù‚Ø¨* (ID-based)"

            await msg.edit_text(text, parse_mode="Markdown")
        else:
            await msg.edit_text(f"âŒ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: `{email}`", parse_mode="Markdown")

    except Exception as e:
        await msg.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def monitored(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show monitored accounts"""

    if not is_admin(update.effective_user.id):
        return

    accounts = load_monitored_accounts()

    if not accounts:
        await update.message.reply_text("ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ø±Ø§Ù‚Ø¨Ø©")
        return

    text = f"ğŸ”„ *Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ({len(accounts)})*\n\n"

    for key, data in accounts.items():
        email = data.get("email", "unknown")
        account_id = data.get("account_id", "N/A")
        status = data["last_known_status"]
        status_ar = get_status_description_ar(status)

        text += (
            f"ğŸ“§ `{email}`\n"
            f"   ğŸ†” `{account_id}`\n"
            f"   ğŸ“Š *{status}*\n"
            f"   {get_status_emoji(status)} {status_ar}\n\n"
        )

    text += f"âš¡ Mode: Hybrid (TTL={smart_cache.cache_ttl:.0f}s)"

    await update.message.reply_text(text, parse_mode="Markdown")

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show stats"""

    if not is_admin(update.effective_user.id):
        return

    global stats

    reset_time = datetime.fromisoformat(stats.last_reset)
    hours = max((datetime.now() - reset_time).seconds / 3600, 0.01)
    requests_per_hour = stats.total_requests / hours

    text = (
        "ğŸ“Š *Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª*\n\n"
        f"ğŸ“ˆ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª: {stats.total_requests}\n"
        f"â±ï¸ Ø§Ù„Ù…Ø¹Ø¯Ù„: {requests_per_hour:.1f} Ø·Ù„Ø¨/Ø³Ø§Ø¹Ø©\n"
        f"ğŸš€ Burst activations: {stats.burst_activations}\n"
        f"âš¡ Ø§ÙƒØªØ´Ø§ÙØ§Øª Ø³Ø±ÙŠØ¹Ø©: {stats.fast_detections}\n"
        f"ğŸ¯ TTL adjustments: {stats.adaptive_adjustments}\n"
        f"ğŸ”„ CSRF refreshes: {stats.csrf_refreshes}\n"
        f"ğŸ“¦ Batch fetches: {stats.batch_fetches}\n"
        f"ğŸ’¾ Cache hits: {stats.cache_hits}\n"
        f"âŒ Errors: {stats.errors}\n"
        f"ğŸ’¾ Cache rate: {(stats.cache_hits / max(stats.total_requests, 1) * 100):.1f}%\n\n"
        f"âš¡ Mode: Adaptive Hybrid\n"
        f"ğŸ§  Current TTL: {smart_cache.cache_ttl:.0f}s\n"
        f"ğŸ• Ù…Ù†Ø°: {reset_time.strftime('%Y-%m-%d %H:%M:%S')}"
    )

    await update.message.reply_text(text, parse_mode="Markdown")

async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show status"""

    if not is_admin(update.effective_user.id):
        return

    accounts = load_monitored_accounts()
    csrf_valid = (
        api_manager.csrf_expires_at and datetime.now() < api_manager.csrf_expires_at
    )

    cache_age = "N/A"
    if smart_cache.cache_timestamp:
        age = (datetime.now() - smart_cache.cache_timestamp).total_seconds()
        cache_age = f"{age:.0f}s"

    text = (
        "*ğŸ“Š Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…*\n\n"
        f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: âœ… Ø´ØºØ§Ù„\n"
        f"âš¡ Mode: *Adaptive Hybrid*\n\n"
        f"ğŸ”‘ CSRF Token: {'âœ… ØµØ§Ù„Ø­' if csrf_valid else 'âš ï¸ Ù…Ù†ØªÙ‡ÙŠ'}\n"
        f"ğŸ’¾ Cache Status: {'âœ… Ù†Ø´Ø·' if smart_cache.cache else 'âŒ ÙØ§Ø±Øº'}\n"
        f"ğŸ• Cache Age: {cache_age}\n"
        f"ğŸ§  Current TTL: {smart_cache.cache_ttl:.0f}s\n"
        f"ğŸš€ Burst Mode: {'âœ… Ù†Ø´Ø·' if smart_cache.burst_mode_active else 'âŒ Ù…Ø¹Ø·Ù„'}\n"
        f"ğŸ”„ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©: {len(accounts)}\n\n"
        f"*âš¡ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª:*\n"
        f"â€¢ Strict ID validation: âœ…\n"
        f"â€¢ Burst mode (60s): âœ…\n"
        f"â€¢ Smart TTL (2-10min): âœ…\n"
        f"â€¢ Fallback mechanism: âœ…\n"
        f"â€¢ Bilingual display: âœ…"
    )

    await update.message.reply_text(text, parse_mode="Markdown")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Main Function
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    """Start the bot"""
    global telegram_app

    print("\n" + "=" * 60)
    print("ğŸš€ SMART SENDER BOT - ADAPTIVE HYBRID MODE")
    print("=" * 60)
    print("ğŸ§  Architecture:")
    print("   â€¢ Smart Cache with adaptive TTL (2-10 min)")
    print("   â€¢ Strict ID Validation (account_id based)")
    print("   â€¢ Temporary Burst Mode (60s on new accounts)")
    print("   â€¢ Fallback Mechanism (resilient to errors)")
    print("   â€¢ Bilingual Status Display (EN/AR)")
    print("\nğŸ“Š Intelligent & Efficient!")
    print("=" * 60 + "\n")

    telegram_app = Application.builder().token(CONFIG["telegram"]["bot_token"]).build()

    telegram_app.add_handler(CommandHandler("start", start))
    telegram_app.add_handler(CommandHandler("search", search))
    telegram_app.add_handler(CommandHandler("monitored", monitored))
    telegram_app.add_handler(CommandHandler("stats", stats_command))
    telegram_app.add_handler(CommandHandler("status", status_command))
    telegram_app.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text)
    )

    async def init_manager(_):
        await api_manager.initialize()
        asyncio.create_task(continuous_monitor())

    telegram_app.job_queue.run_once(init_manager, when=1)

    print("âœ… Bot is running in Adaptive Hybrid Mode!")
    print("ğŸ§  Smart TTL: 2-10 minutes (adaptive)")
    print("ğŸš€ Burst Mode: 60s on new accounts")
    print("ğŸ¯ ID-based validation enabled")
    print("ğŸ“Š Check /stats for metrics\n")

    telegram_app.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nâš ï¸ Bot stopped")
        stats.save()
    except Exception as e:
        print(f"âŒ Error: {e}")
        logger.exception("âŒ Fatal error")
        stats.save()
    finally:
        import asyncio
        asyncio.run(api_manager.close())
