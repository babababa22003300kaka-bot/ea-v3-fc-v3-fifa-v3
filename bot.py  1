#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸš€ Smart Telegram Sender Bot - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
Bot: @snipe12_bot

âœ¨ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©:
- âœ… Strict ID Validation (Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù‡ÙˆÙŠØ©)
- âš¡ Temporary Burst Mode (ÙˆØ¶Ø¹ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø¤Ù‚Øª)
- ğŸ§  Smart TTL Cache (Ø°Ø§ÙƒØ±Ø© Ù…Ø¤Ù‚ØªØ© Ø°ÙƒÙŠØ© Ù…ØªÙƒÙŠÙØ©)
- ğŸ›¡ï¸ Fallback Mechanism (Ø¢Ù„ÙŠØ© Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø©)
- ğŸ“Š Change Detection & History
"""

import asyncio
import json
import logging
import random
import re
from dataclasses import asdict, dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

import aiohttp
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Logging Configuration
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[
        logging.FileHandler("bot.log", encoding="utf-8"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ Load Configuration
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

with open("config.json", "r", encoding="utf-8") as f:
    CONFIG = json.load(f)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ Settings & Constants
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# CSRF Token TTL
CSRF_TOKEN_TTL = 1200  # 20 Ø¯Ù‚ÙŠÙ‚Ø©

# Smart Cache Settings
CACHE_TTL_MIN = 120  # Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ† (ÙÙŠ Ø­Ø§Ù„Ø© Ù†Ø´Ø§Ø· Ù…Ø±ØªÙØ¹)
CACHE_TTL_DEFAULT = 300  # 5 Ø¯Ù‚Ø§Ø¦Ù‚ (Ø¹Ø§Ø¯ÙŠ)
CACHE_TTL_MAX = 600  # 10 Ø¯Ù‚Ø§Ø¦Ù‚ (ÙÙŠ Ø­Ø§Ù„Ø© Ù‡Ø¯ÙˆØ¡)

# Burst Mode Settings
BURST_MODE_DURATION = 60  # Ø«Ø§Ù†ÙŠØ©
BURST_MODE_INTERVAL = (2, 3)  # Ø«Ø§Ù†ÙŠØ©
MEDIUM_MODE_INTERVAL = (4, 5)  # Ø«Ø§Ù†ÙŠØ©
NORMAL_MODE_INTERVAL = (10, 15)  # Ø«Ø§Ù†ÙŠØ©

# Fallback Settings
FALLBACK_RETRY_INTERVAL = 30  # Ø«Ø§Ù†ÙŠØ©
MAX_FALLBACK_ATTEMPTS = 5

# Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ© (Transitional States)
TRANSITIONAL_STATUSES: Set[str] = {
    "LOGGING",
    "LOGGED",
    "LOGGED IN",
    "CODE SENT",
    "WAITING",
}

# Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© (Final States)
FINAL_STATUSES: Set[str] = {
    "AVAILABLE",
    "ACTIVE",
    "WRONG DETAILS",
    "BACKUP CODE WRONG",
    "NEW ACCOUNT",
    "DISABLED",
    "NO TRANSFER ACCESS",
    "TRANSFER LIST IS FULL",
    "NO CLUB",
    "GENERAL LOGIN ERROR",
    "ERROR",
    "BLOCKED",
    "AMOUNT TAKEN",
}

# Database files
MONITORED_ACCOUNTS_FILE = "monitored_accounts.json"
STATS_FILE = "request_stats.json"
CACHE_HEALTH_FILE = "cache_health.json"

# Global vars
telegram_app = None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š Statistics & Health Tracking
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class CacheHealthMetrics:
    """ØªØªØ¨Ø¹ ØµØ­Ø© Ø§Ù„Ù€ Cache Ù„Ù„ØªÙƒÙŠÙ Ø§Ù„Ø°ÙƒÙŠ"""
    recent_changes: List[datetime]  # Ø¢Ø®Ø± Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
    consecutive_failures: int = 0
    last_successful_fetch: Optional[str] = None
    adaptive_ttl: int = CACHE_TTL_DEFAULT
    
    def record_change(self):
        """ØªØ³Ø¬ÙŠÙ„ ØªØºÙŠÙŠØ± Ø¬Ø¯ÙŠØ¯"""
        self.recent_changes.append(datetime.now())
        # Ø§Ø­ØªÙØ¸ Ø¨Ø¢Ø®Ø± 10 ØªØºÙŠÙŠØ±Ø§Øª ÙÙ‚Ø·
        if len(self.recent_changes) > 10:
            self.recent_changes = self.recent_changes[-10:]
    
    def calculate_change_rate(self) -> float:
        """Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª (ØªØºÙŠÙŠØ±Ø§Øª/Ø¯Ù‚ÙŠÙ‚Ø©)"""
        if len(self.recent_changes) < 2:
            return 0.0
        
        time_span = (self.recent_changes[-1] - self.recent_changes[0]).seconds
        if time_span == 0:
            return 0.0
        
        return (len(self.recent_changes) / time_span) * 60
    
    def adjust_ttl(self):
        """Ø¶Ø¨Ø· ÙØªØ±Ø© Ø§Ù„Ù€ TTL Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø´Ø§Ø·"""
        change_rate = self.calculate_change_rate()
        
        if change_rate > 2:  # Ø£ÙƒØ«Ø± Ù…Ù† ØªØºÙŠÙŠØ±ÙŠÙ† ÙÙŠ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©
            self.adaptive_ttl = CACHE_TTL_MIN
            logger.info(f"ğŸ”¥ High activity! TTL reduced to {self.adaptive_ttl}s")
        elif change_rate > 0.5:  # ØªØºÙŠÙŠØ± ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ†
            self.adaptive_ttl = CACHE_TTL_DEFAULT
            logger.info(f"ğŸ“Š Normal activity! TTL set to {self.adaptive_ttl}s")
        else:  # Ù†Ø´Ø§Ø· Ù…Ù†Ø®ÙØ¶
            self.adaptive_ttl = CACHE_TTL_MAX
            logger.info(f"ğŸ˜´ Low activity! TTL increased to {self.adaptive_ttl}s")
    
    def record_failure(self):
        """ØªØ³Ø¬ÙŠÙ„ ÙØ´Ù„"""
        self.consecutive_failures += 1
        logger.warning(f"âŒ Cache fetch failed (attempt {self.consecutive_failures})")
    
    def record_success(self):
        """ØªØ³Ø¬ÙŠÙ„ Ù†Ø¬Ø§Ø­"""
        self.consecutive_failures = 0
        self.last_successful_fetch = datetime.now().isoformat()
    
    def save(self):
        """Ø­ÙØ¸ Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³"""
        try:
            data = {
                "recent_changes": [dt.isoformat() for dt in self.recent_changes],
                "consecutive_failures": self.consecutive_failures,
                "last_successful_fetch": self.last_successful_fetch,
                "adaptive_ttl": self.adaptive_ttl,
            }
            with open(CACHE_HEALTH_FILE, "w") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"âŒ Error saving cache health: {e}")
    
    @classmethod
    def load(cls):
        """ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³"""
        if Path(CACHE_HEALTH_FILE).exists():
            try:
                with open(CACHE_HEALTH_FILE, "r") as f:
                    data = json.load(f)
                    data["recent_changes"] = [
                        datetime.fromisoformat(dt) for dt in data.get("recent_changes", [])
                    ]
                    return cls(**data)
            except:
                pass
        return cls(recent_changes=[])


@dataclass
class RequestStats:
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø·Ù„Ø¨Ø§Øª"""
    total_requests: int = 0
    csrf_refreshes: int = 0
    batch_fetches: int = 0
    cache_hits: int = 0
    errors: int = 0
    fast_detections: int = 0
    burst_requests: int = 0
    fallback_activations: int = 0
    id_validations: int = 0
    last_reset: str = datetime.now().isoformat()

    def save(self):
        try:
            with open(STATS_FILE, "w") as f:
                json.dump(asdict(self), f, indent=2)
        except Exception as e:
            logger.error(f"âŒ Error saving stats: {e}")

    @classmethod
    def load(cls):
        if Path(STATS_FILE).exists():
            try:
                with open(STATS_FILE, "r") as f:
                    return cls(**json.load(f))
            except:
                pass
        return cls()


# Global instances
stats = RequestStats.load()
cache_health = CacheHealthMetrics.load()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ” Optimized API Manager (Ù…Ø¹ ÙƒÙ„ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OptimizedAPIManager:
    """
    Ù…Ø¯ÙŠØ± API Ù…Ø­Ø³Ù‘Ù† Ù…Ø¹:
    - âœ… Smart Cache (Ø°Ø§ÙƒØ±Ø© Ù…Ø¤Ù‚ØªØ© Ø°ÙƒÙŠØ©)
    - âš¡ Burst Mode (ÙˆØ¶Ø¹ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø¤Ù‚Øª)
    - ğŸ§  Adaptive TTL (ÙØªØ±Ø© ØµÙ„Ø§Ø­ÙŠØ© Ù…ØªÙƒÙŠÙØ©)
    - ğŸ›¡ï¸ Fallback Mechanism (Ø¢Ù„ÙŠØ© Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø©)
    - ğŸ”’ Strict ID Validation (Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù‡ÙˆÙŠØ©)
    """

    def __init__(self):
        self.base_url = CONFIG["website"]["urls"]["base"]
        self.cookies = CONFIG["website"]["cookies"]

        # CSRF Token cache
        self.csrf_token = None
        self.csrf_expires_at = None

        # Batch cache (Smart Cache)
        self.all_accounts_cache = None
        self.cache_timestamp = None
        
        # Burst mode state
        self.burst_mode_active = False
        self.burst_mode_email = None
        self.burst_mode_started = None

        # aiohttp session
        self.session = None

    async def initialize(self):
        """Initialize API manager"""
        await self._ensure_session()
        logger.info("ğŸš€ API Manager initialized with all enhancements")
        logger.info("   âœ… Strict ID Validation")
        logger.info("   âš¡ Temporary Burst Mode")
        logger.info("   ğŸ§  Smart TTL Cache")
        logger.info("   ğŸ›¡ï¸ Fallback Mechanism")

    async def _ensure_session(self):
        """Ensure aiohttp session exists"""
        if self.session is None or self.session.closed:
            connector = aiohttp.TCPConnector(limit=15, limit_per_host=8)
            timeout = aiohttp.ClientTimeout(total=30)
            self.session = aiohttp.ClientSession(
                connector=connector, 
                timeout=timeout, 
                cookies=self.cookies
            )

    async def get_csrf_token(self, force_refresh: bool = False) -> Optional[str]:
        """Get CSRF token with caching"""
        global stats

        if not force_refresh and self.csrf_token and self.csrf_expires_at:
            if datetime.now() < self.csrf_expires_at:
                stats.cache_hits += 1
                return self.csrf_token

        logger.info("ğŸ”„ Fetching CSRF token...")
        stats.csrf_refreshes += 1
        stats.total_requests += 1

        await self._ensure_session()

        try:
            async with self.session.get(f"{self.base_url}/senderPage") as response:
                if response.status == 200:
                    html = await response.text()
                    match = re.search(r'<meta name="csrf-token" content="([^"]+)"', html)
                    if match:
                        self.csrf_token = match.group(1)
                        self.csrf_expires_at = datetime.now() + timedelta(seconds=CSRF_TOKEN_TTL)
                        logger.info(f"âœ… CSRF cached ({CSRF_TOKEN_TTL}s)")
                        return self.csrf_token
        except Exception as e:
            logger.error(f"âŒ CSRF fetch error: {e}")
            stats.errors += 1

        return None

    async def fetch_all_accounts_batch(self, force_refresh: bool = False) -> List[Dict]:
        """
        ğŸ¯ Ø§Ù„Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ Ø§Ù„Ø°ÙƒÙŠ (Smart Batch Fetch)
        
        Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª:
        - Adaptive TTL: ÙØªØ±Ø© Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© ØªØªÙƒÙŠÙ Ù…Ø¹ Ø§Ù„Ù†Ø´Ø§Ø·
        - Fallback: ÙŠØ³ØªØ®Ø¯Ù… Ø¢Ø®Ø± Ù†Ø³Ø®Ø© Ù†Ø§Ø¬Ø­Ø© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
        - Health Tracking: ÙŠØªØªØ¨Ø¹ ØµØ­Ø© Ø§Ù„Ù€ Cache
        """
        global stats, cache_health

        # ğŸ§  Ø§Ø³ØªØ®Ø¯Ø§Ù… TTL Ù…ØªÙƒÙŠÙ
        current_ttl = cache_health.adaptive_ttl
        
        # ğŸš€ Burst Mode: Ø¥Ø¬Ø¨Ø§Ø± Ø§Ù„ØªØ­Ø¯ÙŠØ«
        if self.burst_mode_active:
            force_refresh = True
            logger.info("âš¡ BURST MODE: Forcing cache refresh")

        # âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Cache Ø¥Ø°Ø§ ÙƒØ§Ù† ØµØ§Ù„Ø­Ø§Ù‹
        if not force_refresh and self.all_accounts_cache and self.cache_timestamp:
            age = (datetime.now() - self.cache_timestamp).seconds
            if age < current_ttl:
                stats.cache_hits += 1
                logger.debug(f"ğŸ’¾ Cache hit (age: {age}s, TTL: {current_ttl}s)")
                return self.all_accounts_cache

        logger.info(f"ğŸ”„ Batch fetch (TTL: {current_ttl}s)...")
        stats.batch_fetches += 1
        stats.total_requests += 1

        csrf = await self.get_csrf_token()
        if not csrf:
            # ğŸ›¡ï¸ Fallback: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¢Ø®Ø± cache Ù†Ø§Ø¬Ø­
            return await self._fallback_to_cache()

        await self._ensure_session()

        try:
            payload = {"date": "0", "bigUpdate": "0", "csrf_token": csrf}

            async with self.session.post(
                f"{self.base_url}/dataFunctions/updateSenderPage", 
                data=payload
            ) as response:

                if response.status == 200:
                    data = await response.json()

                    if "data" in data:
                        accounts = data["data"]
                        parsed = self._parse_accounts(accounts)

                        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ Cache
                        old_cache = self.all_accounts_cache or []
                        self.all_accounts_cache = parsed
                        self.cache_timestamp = datetime.now()

                        # ğŸ§  ØªØªØ¨Ø¹ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ù„ØªØ­Ø¯ÙŠØ« TTL
                        changes_detected = self._detect_changes(old_cache, parsed)
                        if changes_detected > 0:
                            for _ in range(changes_detected):
                                cache_health.record_change()
                            cache_health.adjust_ttl()
                            cache_health.save()

                        # âœ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ø¬Ø§Ø­
                        cache_health.record_success()
                        cache_health.save()

                        logger.info(f"âœ… Fetched {len(parsed)} accounts ({changes_detected} changes)")
                        return parsed

                elif response.status in [403, 419]:
                    self.csrf_token = None
                    return await self.fetch_all_accounts_batch(force_refresh=True)
                else:
                    # ğŸ›¡ï¸ Fallback Ø¹Ù„Ù‰ Ø®Ø·Ø£ HTTP
                    cache_health.record_failure()
                    return await self._fallback_to_cache()

        except Exception as e:
            logger.error(f"âŒ Batch fetch error: {e}")
            stats.errors += 1
            cache_health.record_failure()
            cache_health.save()
            
            # ğŸ›¡ï¸ Fallback
            return await self._fallback_to_cache()

    async def _fallback_to_cache(self) -> List[Dict]:
        """
        ğŸ›¡ï¸ Ø¢Ù„ÙŠØ© Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø© (Fallback Mechanism)
        
        ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨:
        - ÙŠØ³ØªØ®Ø¯Ù… Ø¢Ø®Ø± Ù†Ø³Ø®Ø© Ù†Ø§Ø¬Ø­Ø© Ù…Ù† Ø§Ù„Ù€ Cache
        - ÙŠØ³Ø¬Ù„ Ø§Ù„ÙØ´Ù„
        - ÙŠØ­Ø§ÙˆÙ„ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ø¹Ø¯ ÙØªØ±Ø© Ù‚ØµÙŠØ±Ø©
        """
        global stats
        
        stats.fallback_activations += 1
        
        if self.all_accounts_cache:
            cache_age = (datetime.now() - self.cache_timestamp).seconds if self.cache_timestamp else 999999
            logger.warning(
                f"ğŸ›¡ï¸ FALLBACK: Using last successful cache (age: {cache_age}s, "
                f"failures: {cache_health.consecutive_failures})"
            )
            
            # Ø¬Ø¯ÙˆÙ„Ø© Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ø¯ÙŠØ« Ù‚Ø±ÙŠØ¨Ø©
            if cache_health.consecutive_failures < MAX_FALLBACK_ATTEMPTS:
                asyncio.create_task(self._retry_fetch_after_delay())
            
            return self.all_accounts_cache
        else:
            logger.error("âŒ FALLBACK: No cache available!")
            return []

    async def _retry_fetch_after_delay(self):
        """Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø¨ Ø¨Ø¹Ø¯ ÙØªØ±Ø© Ù‚ØµÙŠØ±Ø©"""
        await asyncio.sleep(FALLBACK_RETRY_INTERVAL)
        logger.info(f"ğŸ”„ Retrying batch fetch after {FALLBACK_RETRY_INTERVAL}s delay...")
        await self.fetch_all_accounts_batch(force_refresh=True)

    def _parse_accounts(self, accounts: List) -> List[Dict]:
        """ØªØ­Ù„ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª"""
        INDEX_MAP = {
            "idAccount": 0,
            "image": 1,
            "Sender": 2,
            "Start": 3,
            "Last Update": 4,
            "Taken": 5,
            "Status": 6,
            "Available": 7,
            "password": 8,
            "backupCodes": 9,
            "Group": 10,
            "groupNameId": 11,
            "Take": 12,
            "Keep": 13,
        }

        parsed = []
        for account in accounts:
            if len(account) > INDEX_MAP["Sender"]:
                acc = {}
                for key, idx in INDEX_MAP.items():
                    acc[key] = (
                        str(account[idx])
                        if idx < len(account) and account[idx]
                        else ""
                    )
                parsed.append(acc)
        
        return parsed

    def _detect_changes(self, old_cache: List[Dict], new_cache: List[Dict]) -> int:
        """Ø§ÙƒØªØ´Ø§Ù Ø¹Ø¯Ø¯ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ù€ Cache Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯"""
        if not old_cache:
            return 0

        old_dict = {acc.get("idAccount"): acc.get("Status") for acc in old_cache}
        new_dict = {acc.get("idAccount"): acc.get("Status") for acc in new_cache}

        changes = 0
        for acc_id, new_status in new_dict.items():
            if acc_id in old_dict and old_dict[acc_id] != new_status:
                changes += 1

        return changes

    async def search_sender(self, email: str, account_id: Optional[str] = None, 
                          force_refresh: bool = False) -> Optional[Dict]:
        """
        ğŸ”’ Ø§Ù„Ø¨Ø­Ø« Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù‡ÙˆÙŠØ© (Strict ID Validation)
        
        Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª:
        - Ø¥Ø°Ø§ ÙƒØ§Ù† account_id Ù…ØªÙˆÙØ±Ø§Ù‹ØŒ ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ù€ ID Ø£ÙˆÙ„Ø§Ù‹
        - Ø«Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ÙƒØ®Ø·ÙˆØ© Ø«Ø§Ù†ÙˆÙŠØ©
        - ÙŠÙ…Ù†Ø¹ Ø®Ù„Ø· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªÙ…Ø§Ù…Ø§Ù‹
        """
        global stats
        
        email = email.lower().strip()
        accounts = await self.fetch_all_accounts_batch(force_refresh=force_refresh)

        # ğŸ”’ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆÙØ±Ø§Ù‹
        if account_id:
            stats.id_validations += 1
            
            for account in accounts:
                if account.get("idAccount") == account_id:
                    # ØªØ£ÙƒÙŠØ¯ Ø¥Ø¶Ø§ÙÙŠ: Ù‡Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ù…Ø·Ø§Ø¨Ù‚ØŸ
                    if account.get("Sender", "").lower() == email:
                        logger.debug(f"âœ… ID validation passed: {email} (ID: {account_id})")
                        return account
                    else:
                        logger.warning(
                            f"âš ï¸ ID matched but email mismatch! "
                            f"Expected: {email}, Got: {account.get('Sender')}"
                        )
                        return None  # ID Ù…Ø·Ø§Ø¨Ù‚ Ù„ÙƒÙ† Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ù…Ø®ØªÙ„Ù = Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­Ø±ÙØ©

        # Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø¹Ø§Ø¯ÙŠ Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ÙÙ‚Ø·
        for account in accounts:
            if account.get("Sender", "").lower() == email:
                return account

        return None

    async def activate_burst_mode(self, email: str):
        """
        âš¡ ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø¤Ù‚Øª (Temporary Burst Mode)
        
        Ø¹Ù†Ø¯ Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯:
        - ÙŠÙØ±Ø¶ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø³Ø±ÙŠØ¹Ø© ÙƒÙ„ 2-3 Ø«ÙˆØ§Ù†Ù
        - Ù„Ù…Ø¯Ø© 60 Ø«Ø§Ù†ÙŠØ© ÙÙ‚Ø·
        - Ø«Ù… ÙŠØ¹ÙˆØ¯ Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¹Ø§Ø¯ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
        """
        self.burst_mode_active = True
        self.burst_mode_email = email
        self.burst_mode_started = datetime.now()
        
        logger.info(f"âš¡ BURST MODE ACTIVATED for {email} ({BURST_MODE_DURATION}s)")
        
        # Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù€ Burst Mode ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
        asyncio.create_task(self._auto_deactivate_burst_mode())

    async def _auto_deactivate_burst_mode(self):
        """Ø¥Ù„ØºØ§Ø¡ Burst Mode ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©"""
        await asyncio.sleep(BURST_MODE_DURATION)
        
        if self.burst_mode_active:
            self.burst_mode_active = False
            elapsed = (datetime.now() - self.burst_mode_started).seconds
            logger.info(
                f"âœ… BURST MODE DEACTIVATED after {elapsed}s "
                f"(email: {self.burst_mode_email})"
            )
            self.burst_mode_email = None
            self.burst_mode_started = None

    async def add_sender(self, email: str, password: str, backup_codes: str = "",
                        amount_take: str = "", amount_keep: str = "") -> Tuple[bool, str]:
        """Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ Ù…Ø¹ ØªÙØ¹ÙŠÙ„ Burst Mode"""
        global stats

        csrf = await self.get_csrf_token()
        if not csrf:
            return False, "No CSRF"

        stats.total_requests += 1
        await self._ensure_session()

        defaults = CONFIG["website"]["defaults"]
        payload = {
            "email": email,
            "password": password,
            "backupCodes": backup_codes,
            "groupName": defaults["group_name"],
            "accountLock": defaults["account_lock"],
            "amountToTake": amount_take or defaults.get("amount_take", ""),
            "amountToKeep": amount_keep or defaults.get("amount_keep", ""),
            "priority": defaults.get("priority", ""),
            "forceProxy": defaults.get("force_proxy", ""),
            "userPrice": defaults.get("user_price", ""),
            "csrf_token": csrf,
        }

        try:
            async with self.session.post(
                f"{self.base_url}/dataFunctions/addAccount", 
                json=payload
            ) as response:

                if response.status == 200:
                    try:
                        data = await response.json()
                        if "success" in data:
                            # âš¡ ØªÙØ¹ÙŠÙ„ Burst Mode
                            await self.activate_burst_mode(email)
                            
                            self.cache_timestamp = None
                            return True, data.get("success", "Success")
                        elif "error" in data:
                            error = data.get("error", "")
                            if "already" in error.lower():
                                # âš¡ ØªÙØ¹ÙŠÙ„ Burst Mode Ø­ØªÙ‰ Ù„Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
                                await self.activate_burst_mode(email)
                                return True, "Exists"
                            return False, error
                    except:
                        text = await response.text()
                        if "success" in text.lower():
                            await self.activate_burst_mode(email)
                            self.cache_timestamp = None
                            return True, "Success"
                        return False, text[:100]

                elif response.status in [403, 419]:
                    self.csrf_token = None
                    return False, "CSRF expired"

                return False, f"Status {response.status}"

        except Exception as e:
            stats.errors += 1
            return False, str(e)

    async def _send_status_notification(self, email: str, account_id: str,
                                       old_status: str, new_status: str,
                                       chat_id: int, account_data: Dict):
        """Ø¥Ø±Ø³Ø§Ù„ ØªÙ†Ø¨ÙŠÙ‡ ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©"""
        try:
            old_emoji = get_status_emoji(old_status)
            new_emoji = get_status_emoji(new_status)
            old_status_ar = get_status_description_ar(old_status)
            new_status_ar = get_status_description_ar(new_status)

            notification = (
                f"ğŸ”” *ØªÙ†Ø¨ÙŠÙ‡ ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©!*\n\n"
                f"ğŸ“§ Ø§Ù„Ø¨Ø±ÙŠØ¯: `{email}`\n"
                f"ğŸ†” ID: `{account_id}`\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©:*\n"
                f"   `{old_status}`\n"
                f"   {old_emoji} {old_status_ar}\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:*\n"
                f"   `{new_status}`\n"
                f"   {new_emoji} {new_status_ar}\n\n"
                f"ğŸ• Ø§Ù„ÙˆÙ‚Øª: {datetime.now().strftime('%H:%M:%S')}\n"
            )

            available = format_number(account_data.get("Available", "0"))
            taken = format_number(account_data.get("Taken", "0"))

            if available != "0" or taken != "0":
                notification += f"\nğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {available}\nâœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {taken}\n"

            notification += f"\nğŸ’¡ `/search {email}` Ù„Ù„ØªÙØ§ØµÙŠÙ„"

            await telegram_app.bot.send_message(
                chat_id=chat_id, 
                text=notification, 
                parse_mode="Markdown"
            )

        except Exception as e:
            logger.error(f"âŒ Failed to send notification: {e}")

    async def close(self):
        """Cleanup"""
        if self.session and not self.session.closed:
            await self.session.close()
        
        # Ø­ÙØ¸ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        stats.save()
        cache_health.save()


# Global API manager
api_manager = OptimizedAPIManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¾ Database Functions (Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ù€ ID)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def load_monitored_accounts() -> Dict:
    if Path(MONITORED_ACCOUNTS_FILE).exists():
        try:
            with open(MONITORED_ACCOUNTS_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except:
            pass
    return {}


def save_monitored_accounts(accounts: Dict):
    try:
        with open(MONITORED_ACCOUNTS_FILE, "w", encoding="utf-8") as f:
            json.dump(accounts, f, indent=2, ensure_ascii=False)
    except Exception as e:
        logger.error(f"âŒ Save error: {e}")


def add_monitored_account(email: str, account_id: str, status: str, chat_id: int):
    """
    ğŸ”’ Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø¹ Ø§Ù„Ù‡ÙˆÙŠØ© Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø© (Trusted Identity)
    
    Ø§Ù„ØªØ­Ø³ÙŠÙ†: ØªØ®Ø²ÙŠÙ† account_id ÙƒÙ€ "Ù‡ÙˆÙŠØ© Ù…ÙˆØ«ÙˆÙ‚Ø©" Ù„Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù…
    """
    accounts = load_monitored_accounts()
    accounts[email] = {
        "account_id": account_id,  # ğŸ”’ Ø§Ù„Ù‡ÙˆÙŠØ© Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
        "last_known_status": status,
        "chat_id": chat_id,
        "added_at": datetime.now().isoformat(),
        "last_check": datetime.now().isoformat(),
    }
    save_monitored_accounts(accounts)
    logger.info(f"âœ… Added {email} to monitoring (ID: {account_id})")


def update_monitored_account_status(email: str, new_status: str):
    accounts = load_monitored_accounts()
    if email in accounts:
        accounts[email]["last_known_status"] = new_status
        accounts[email]["last_check"] = datetime.now().isoformat()
        save_monitored_accounts(accounts)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ Helper Functions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def is_admin(user_id: int) -> bool:
    admin_ids = CONFIG["telegram"].get("admin_ids", [])
    return not admin_ids or user_id in admin_ids


def format_number(value) -> str:
    if value is None or value == "" or value == "null":
        return "0"

    try:
        value_str = str(value).strip()
        if not value_str.replace(".", "", 1).replace("-", "", 1).isdigit():
            return value_str

        num = float(value_str)

        if abs(num) < 1000:
            return str(int(num)) if num == int(num) else str(num)

        k_value = num / 1000

        if abs(k_value) >= 1000:
            return f"{k_value:,.0f}k"
        else:
            return f"{int(k_value)}k"
    except:
        return str(value)


def get_status_emoji(status: str) -> str:
    emoji_map = {
        "LOGGING": "ğŸ”„", "LOGGED": "âœ…", "LOGGED IN": "ğŸ‘¤",
        "ACTIVE": "âœ…", "AVAILABLE": "ğŸ’°", "CODE SENT": "ğŸ“§",
        "AMOUNT TAKEN": "ğŸ’¸", "WRONG DETAILS": "âš ï¸",
        "NEW ACCOUNT": "ğŸ†•", "DISABLED": "ğŸ”’",
        "NO TRANSFER ACCESS": "ğŸš«", "BACKUP CODE WRONG": "ğŸ”‘",
        "TRANSFER LIST IS FULL": "ğŸ“¦", "NO CLUB": "â›”",
        "GENERAL LOGIN ERROR": "â—", "ERROR": "âŒ",
        "WAITING": "â³", "BLOCKED": "ğŸš«",
    }
    return emoji_map.get(status.upper(), "ğŸ“Š")


def get_status_description_ar(status: str) -> str:
    descriptions = {
        "LOGGING": "Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        "LOGGED": "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        "LOGGED IN": "Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¯Ø®Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨",
        "ACTIVE": "Ù†Ø´Ø·",
        "AVAILABLE": "Ù…ØªØ§Ø­ - Ø§Ù„Ø­Ø³Ø§Ø¨ ØªÙ…Ø§Ù… ÙˆØ¬Ø§Ù‡Ø² Ù„Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª",
        "CODE SENT": "Ø§Ù„ÙƒÙˆØ¯ Ø§ØªØ¨Ø¹Øª",
        "AMOUNT TAKEN": "Ø§Ù„ÙÙ„ÙˆØ³ (Ø§Ù„ÙƒÙˆÙŠÙ†Ø²) Ø§ØªØ£Ø®Ø¯Øª ÙˆØ§Ù„ÙƒÙˆÙŠÙ†Ø² Ø§ØªÙ†Ù‚Ù„Øª",
        "WRONG DETAILS": "Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙ„Ø· - Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ø£Ùˆ Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯ Ø£Ùˆ Ø§Ù„Ù€ EA Account Ù…Ø´ ØµØ­",
        "NEW ACCOUNT": "Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯ - Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯ ÙˆÙ…Ø§ ÙÙŠÙ‡ÙˆØ´ Ù„Ø§Ø¹ÙŠØ¨Ø© ÙƒÙØ§ÙŠØ©",
        "DISABLED": "Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø·Ù„",
        "NO TRANSFER ACCESS": "Ù…Ø§Ø±ÙƒØª Ù…Ù‚ÙÙˆÙ„ - ÙˆÙŠØ¨ Ø§Ø¨ Ù…Ù‚ÙÙˆÙ„ - Companion Ù…Ù‚ÙÙˆÙ„",
        "BACKUP CODE WRONG": "Ø§ÙƒÙˆØ§Ø¯ ØºÙ„Ø· - Ø¬Ø¯Ø¯ Ø§ÙƒÙˆØ§Ø¯ ÙˆØ§Ø¨Ø¹ØªÙ‡Ù… ØªØ§Ù†ÙŠ",
        "TRANSFER LIST IS FULL": "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª ÙƒØ§Ù…Ù„Ø© - ÙØ¶ÙŠ Ù…Ø§Ø±ÙƒØª Ø´ÙˆÙŠØ© ÙˆØ§Ø¨Ø¹Øª (Ù„Ø§Ø¹ÙŠØ¨Ø©)",
        "NO CLUB": "Ù…Ø§ ÙÙŠØ´ ÙƒÙ„ÙˆØ¨",
        "GENERAL LOGIN ERROR": "Ù…Ø´ÙƒÙ„Ø© Ø¹Ø§Ù…Ø© ÙÙŠ Ø§Ù„Ø¯Ø®ÙˆÙ„ - Ø®Ø·Ø£ Ø¹Ø´ÙˆØ§Ø¦ÙŠ ÙÙŠ Ø§Ù„Ù„ÙˆØ¬ Ø¥Ù†",
        "ERROR": "Ø®Ø·Ø£ Ø¹Ø§Ù…",
        "WAITING": "Ù…Ù†ØªØ¸Ø±",
        "BLOCKED": "Ù…Ø­Ø¸ÙˆØ±",
    }
    return descriptions.get(status.upper(), status)


def parse_sender_data(text: str) -> Dict:
    lines = text.strip().split("\n")
    data = {
        "email": "",
        "password": "",
        "codes": [],
        "amount_take": "",
        "amount_keep": "",
    }

    email_pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"

    for line in lines:
        line = line.strip()
        if not line:
            continue

        if re.match(email_pattern, line):
            data["email"] = line.lower()
        elif "Ø§Ø³Ø­Ø¨" in line:
            match = re.search(r"Ø§Ø³Ø­Ø¨\s*(\d+)", line)
            if match:
                data["amount_take"] = match.group(1)
        elif "ÙŠØ³ÙŠØ¨" in line:
            match = re.search(r"ÙŠØ³ÙŠØ¨\s*(\d+)", line)
            if match:
                data["amount_keep"] = match.group(1)
        elif re.match(r"^[\d.]+$", line):
            clean_code = line.split(".")[-1] if "." in line else line
            data["codes"].append(clean_code)
        elif data["email"] and not data["password"]:
            data["password"] = line

    data["codes"] = ",".join(data["codes"])
    return data


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ” Ultra-Fast Burst Mode Monitoring (Ù…Ø­Ø³Ù‘Ù†)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def wait_for_status_change(email: str, message_obj, chat_id: int) -> Tuple[bool, Optional[Dict]]:
    """
    ğŸš€ Ù…Ø±Ø§Ù‚Ø¨Ø© ÙØ§Ø¦Ù‚Ø© Ø§Ù„Ø³Ø±Ø¹Ø© Ù…Ø¹ Burst Mode Ø§Ù„Ù…Ø­Ø³Ù‘Ù†
    
    Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:
    - âœ… ÙŠØ³ØªÙÙŠØ¯ Ù…Ù† Burst Mode Ø§Ù„Ù…ÙØ¹Ù‘Ù„ ÙÙŠ Ø§Ù„Ù€ API Manager
    - ğŸ”’ ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù€ ID
    - ğŸ“Š ÙŠØªØªØ¨Ø¹ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø¨Ø¯Ù‚Ø©
    """
    global stats

    await asyncio.sleep(1.0)

    start_time = datetime.now()
    total_elapsed = 0
    last_status = None
    last_account_id = None
    status_changes = []
    stable_count = 0
    max_attempts = 60

    logger.info(f"ğŸš€ Starting enhanced BURST MODE monitoring for {email}")

    for attempt in range(1, max_attempts + 1):
        try:
            # ğŸš€ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Burst Mode
            if total_elapsed < 30:
                force_refresh = True
                interval_range = BURST_MODE_INTERVAL
                mode = "ğŸš€ BURST"
                stats.burst_requests += 1
            elif total_elapsed < 60:
                force_refresh = attempt % 2 == 0
                interval_range = MEDIUM_MODE_INTERVAL
                mode = "âš¡ MEDIUM"
            else:
                force_refresh = attempt % 5 == 0
                interval_range = NORMAL_MODE_INTERVAL
                mode = "ğŸ”„ NORMAL"

            # ğŸ”’ Ø§Ù„Ø¨Ø­Ø« Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆÙØ±Ø§Ù‹
            account_info = await api_manager.search_sender(
                email, 
                account_id=last_account_id,
                force_refresh=force_refresh
            )

            if not account_info:
                interval = random.uniform(*interval_range)

                await message_obj.edit_text(
                    f"{mode} *Ø¨Ø­Ø« Ø³Ø±ÙŠØ¹*\n\n"
                    f"ğŸ“§ `{email}`\n"
                    f"ğŸ” Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©: {attempt}/{max_attempts}\n"
                    f"â±ï¸ Ø§Ù„ÙˆÙ‚Øª: {int(total_elapsed)}s\n"
                    f"{'ğŸ”¥ Ø·Ù„Ø¨ Ø­Ù‚ÙŠÙ‚ÙŠ' if force_refresh else 'ğŸ’¾ Ù…Ù† Ø§Ù„Ù€ cache'}",
                    parse_mode="Markdown",
                )

                total_elapsed += interval
                await asyncio.sleep(interval)
                continue

            # Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ - Ù†Ø­Ù„Ù„ Ø§Ù„Ø­Ø§Ù„Ø©
            status = account_info.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯").upper()
            account_id = account_info.get("idAccount", "N/A")

            # ğŸ”’ Ø­ÙØ¸ Ø§Ù„Ù€ ID Ù„Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ
            if not last_account_id:
                last_account_id = account_id

            # Ù‡Ù„ Ø§Ù„Ø­Ø§Ù„Ø© ØªØºÙŠØ±ØªØŸ
            if status != last_status:
                change_time = (datetime.now() - start_time).total_seconds()
                logger.info(f"ğŸ“Š {email} status changed to: {status} at {change_time:.1f}s")

                status_changes.append({
                    "status": status,
                    "time": datetime.now(),
                    "elapsed": total_elapsed
                })

                if last_status and status in FINAL_STATUSES:
                    stats.fast_detections += 1
                    logger.info(f"âš¡ FAST DETECTION: {last_status} â†’ {status} in {change_time:.1f}s")

                last_status = status
                stable_count = 0
            else:
                stable_count += 1

            # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø­Ø§Ù„Ø©
            is_final = status in FINAL_STATUSES
            is_transitional = status in TRANSITIONAL_STATUSES

            # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
            status_ar = get_status_description_ar(status)
            status_type = (
                "âœ… Ù†Ù‡Ø§Ø¦ÙŠØ©" if is_final
                else "â³ Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ©" if is_transitional 
                else "â“ ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©"
            )

            # Ø¹Ø±Ø¶ Ø³Ø¬Ù„ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
            changes_text = ""
            if len(status_changes) > 1:
                changes_text = "\nğŸ“ *Ø³Ø¬Ù„ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª:*\n"
                for i, change in enumerate(status_changes[-3:]):
                    changes_text += f"   {i+1}. `{change['status']}` ({change['elapsed']:.1f}s)\n"

            # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Burst Mode
            burst_info = ""
            if api_manager.burst_mode_active:
                burst_remaining = BURST_MODE_DURATION - total_elapsed
                burst_info = f"\nâš¡ Burst Mode: {max(0, int(burst_remaining))}s remaining"

            await message_obj.edit_text(
                f"{mode} *Ù…Ø±Ø§Ù‚Ø¨Ø© ÙØ§Ø¦Ù‚Ø©*\n\n"
                f"ğŸ“§ `{email}`\n"
                f"ğŸ†” ID: `{account_id}`\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø©:* `{status}`\n"
                f"   {get_status_emoji(status)} {status_ar}\n\n"
                f"ğŸ¯ Ø§Ù„Ù†ÙˆØ¹: {status_type}\n"
                f"ğŸ”„ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±: {stable_count}/2\n"
                f"{changes_text}"
                f"â±ï¸ Ø§Ù„ÙˆÙ‚Øª: {int(total_elapsed)}s\n"
                f"ğŸ” Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©: {attempt}/{max_attempts}\n"
                f"{'ğŸ”¥ Ø·Ù„Ø¨ Ø­Ù‚ÙŠÙ‚ÙŠ' if force_refresh else 'ğŸ’¾ Ù…Ù† Ø§Ù„Ù€ cache'}"
                f"{burst_info}",
                parse_mode="Markdown",
            )

            # ğŸ¯ Ù…Ù†Ø·Ù‚ Ø§Ù„Ù‚Ø±Ø§Ø± Ù„Ù„ØªÙˆÙ‚Ù
            if is_final:
                if stable_count >= 2:
                    response_time = (datetime.now() - start_time).total_seconds()
                    logger.info(f"âœ… {email} STABLE at {status} in {response_time:.1f}s")

                    # ğŸ”’ Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø¹ Ø§Ù„Ù€ ID Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚
                    if status in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
                        add_monitored_account(email, account_id, status, chat_id)

                    return True, account_info
                else:
                    interval = random.uniform(2.0, 3.0)

            elif is_transitional:
                interval = random.uniform(*interval_range)
            else:
                interval = random.uniform(*interval_range)

            if status == "LOGGING":
                interval = min(interval, 2.5)

            if stable_count >= 10 and is_transitional:
                logger.warning(f"âš ï¸ {email}: {status} stuck for {stable_count} attempts")

            if total_elapsed > 120:
                logger.warning(f"â±ï¸ {email}: Timeout at {status}")
                if status in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
                    add_monitored_account(email, account_id, status, chat_id)
                return True, account_info

            total_elapsed += interval
            await asyncio.sleep(interval)

        except Exception as e:
            logger.exception(f"âŒ Monitoring error #{attempt}: {e}")
            await asyncio.sleep(2.0)
            total_elapsed += 2.0

    # ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰
    logger.warning(f"âš ï¸ {email}: Max attempts reached, final status: {last_status}")

    if "account_info" in locals() and account_info:
        status = account_info.get("Status", "").upper()
        account_id = account_info.get("idAccount", "N/A")

        if status in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
            add_monitored_account(email, account_id, status, chat_id)

        return True, account_info

    return False, None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ Background Monitor (Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ù€ ID)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def continuous_monitor():
    """
    ğŸ”„ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø© ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
    
    Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª:
    - ğŸ”’ ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù€ ID
    - ğŸ§  ÙŠØ³ØªÙÙŠØ¯ Ù…Ù† Smart TTL
    - ğŸ›¡ï¸ ÙŠØ³ØªÙÙŠØ¯ Ù…Ù† Fallback Mechanism
    """
    logger.info("ğŸ”„ Background monitor started with enhanced features...")

    while True:
        try:
            accounts = load_monitored_accounts()

            if not accounts:
                await asyncio.sleep(30)
                continue

            # ğŸ§  Ø§Ø³ØªØ®Ø¯Ø§Ù… Smart Cache
            all_accounts = await api_manager.fetch_all_accounts_batch()
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù…ÙˆØ³ Ù„Ù„Ø¨Ø­Ø« Ø§Ù„Ø³Ø±ÙŠØ¹ Ø¨Ø§Ù„Ù€ ID
            accounts_by_id = {
                acc.get("idAccount"): acc 
                for acc in all_accounts 
                if acc.get("idAccount")
            }

            for email, data in list(accounts.items()):
                try:
                    # ğŸ”’ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù€ ID
                    trusted_id = data.get("account_id")
                    
                    if trusted_id and trusted_id in accounts_by_id:
                        account_info = accounts_by_id[trusted_id]
                        
                        # ØªØ£ÙƒÙŠØ¯ Ø¥Ø¶Ø§ÙÙŠ: Ù‡Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ù…Ø·Ø§Ø¨Ù‚ØŸ
                        if account_info.get("Sender", "").lower() != email.lower():
                            logger.warning(
                                f"âš ï¸ ID/Email mismatch for {email}! "
                                f"ID: {trusted_id}, Found email: {account_info.get('Sender')}"
                            )
                            continue
                    else:
                        # Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ÙƒØ¨Ø¯ÙŠÙ„
                        account_info = await api_manager.search_sender(email)
                        
                        if not account_info:
                            logger.warning(f"âš ï¸ {email} not found in batch!")
                            continue

                    current_status = account_info.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯").upper()
                    last_status = data["last_known_status"].upper()

                    if current_status != last_status:
                        logger.info(f"ğŸ”” {email}: {last_status} â†’ {current_status}")

                        # Ø­Ø§Ù„Ø§Øª ØªØ­ØªØ§Ø¬ Ø§Ù‡ØªÙ…Ø§Ù…
                        if current_status in ["BACKUP CODE WRONG", "WRONG DETAILS"]:
                            logger.warning(f"âš ï¸ {email} needs attention: {current_status}")
                        elif current_status == "TRANSFER LIST IS FULL":
                            logger.info(f"ğŸ“¦ {email} transfer list full - needs clearing")
                        elif current_status == "AMOUNT TAKEN":
                            logger.info(f"ğŸ’¸ {email} amount was taken successfully")

                        update_monitored_account_status(email, current_status)

                        # Ø¥Ø±Ø³Ø§Ù„ ØªÙ†Ø¨ÙŠÙ‡
                        await api_manager._send_status_notification(
                            email,
                            data["account_id"],
                            last_status,
                            current_status,
                            data["chat_id"],
                            account_info,
                        )
                    else:
                        update_monitored_account_status(email, current_status)

                except Exception as e:
                    logger.exception(f"âŒ Error checking {email}")

            # ğŸ§  ÙØªØ±Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§Ù„Ø§Øª
            statuses = [d["last_known_status"] for d in accounts.values()]

            if "LOGGING" in statuses:
                cycle_delay = random.uniform(10, 20)
            elif "AVAILABLE" in statuses or "ACTIVE" in statuses:
                cycle_delay = random.uniform(30, 60)
            else:
                cycle_delay = random.uniform(60, 120)

            logger.debug(f"ğŸ’¤ Next check in {cycle_delay:.1f}s (Adaptive TTL: {cache_health.adaptive_ttl}s)")
            await asyncio.sleep(cycle_delay)

        except Exception as e:
            logger.exception("âŒ Monitor error")
            await asyncio.sleep(30)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ Bot Commands
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user

    if not is_admin(user.id):
        await update.message.reply_text("âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†.")
        return

    welcome_msg = (
        f"Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.first_name}! ğŸ‘‹\n\n"
        "ğŸš€ *Ø¨ÙˆØª Ø§Ù„Ø³ÙŠÙ†Ø¯Ø±Ø² Ø§Ù„Ù…ØªØ·ÙˆØ± - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©*\n\n"
        "*âœ¨ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©:*\n"
        "âœ… Strict ID Validation - Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù‡ÙˆÙŠØ©\n"
        "âš¡ Temporary Burst Mode - ÙˆØ¶Ø¹ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø¤Ù‚Øª\n"
        "ğŸ§  Smart TTL Cache - Ø°Ø§ÙƒØ±Ø© Ù…ØªÙƒÙŠÙØ© Ø°ÙƒÙŠØ©\n"
        "ğŸ›¡ï¸ Fallback Mechanism - Ø¢Ù„ÙŠØ© Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø©\n"
        "ğŸ“Š Change Detection - ØªØªØ¨Ø¹ Ø¯Ù‚ÙŠÙ‚ Ù„Ù„ØªØºÙŠÙŠØ±Ø§Øª\n\n"
        "*ğŸ“ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¥Ø¶Ø§ÙØ©:*\n"
        "```\n"
        "email@gmail.com\n"
        "password123\n"
        "12345678\n"
        "Ø§Ø³Ø­Ø¨ 100\n"
        "ÙŠØ³ÙŠØ¨ 50\n"
        "```\n\n"
        "*â±ï¸ Ø²Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©: 3-8 Ø«ÙˆØ§Ù†Ù*\n\n"
        "*ğŸ” Ø§Ù„Ø£ÙˆØ§Ù…Ø±:*\n"
        "`/search email@gmail.com`\n"
        "`/monitored` - Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©\n"
        "`/stats` - Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª\n"
        "`/status` - Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…\n"
        "`/health` - ØµØ­Ø© Ø§Ù„Ù€ Cache"
    )

    await update.message.reply_text(welcome_msg, parse_mode="Markdown")


async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return

    if update.message.text.startswith("/"):
        return

    data = parse_sender_data(update.message.text)

    if not data["email"] or not data["password"]:
        await update.message.reply_text("âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©!")
        return

    msg = await update.message.reply_text(
        f"â³ *Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø¶Ø§ÙØ©...*\nğŸ“§ `{data['email']}`", 
        parse_mode="Markdown"
    )

    try:
        # âš¡ Ø³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Burst Mode ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙÙŠ add_sender
        success, message = await api_manager.add_sender(
            email=data["email"],
            password=data["password"],
            backup_codes=data["codes"],
            amount_take=data["amount_take"],
            amount_keep=data["amount_keep"],
        )

        if success:
            await msg.edit_text(
                f"âœ… *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©!*\n"
                f"ğŸ“§ `{data['email']}`\n\n"
                f"âš¡ *BURST MODE Ù…ÙØ¹Ù‘Ù„!*\n"
                f"ğŸš€ ØªØ­Ø¯ÙŠØ«Ø§Øª ÙƒÙ„ 2-3 Ø«ÙˆØ§Ù†Ù Ù„Ù…Ø¯Ø© 60 Ø«Ø§Ù†ÙŠØ©\n"
                f"â±ï¸ Ù…ØªÙˆÙ‚Ø¹: 3-8 Ø«ÙˆØ§Ù†Ù",
                parse_mode="Markdown",
            )

            monitoring_success, account_info = await wait_for_status_change(
                data["email"], msg, update.effective_chat.id
            )

            if account_info:
                status = account_info.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
                status_ar = get_status_description_ar(status)
                account_id = account_info.get("idAccount", "N/A")

                result_text = (
                    f"âœ… *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø¨Ù†Ø¬Ø§Ø­!*\n\n"
                    f"ğŸ“§ `{data['email']}`\n"
                    f"ğŸ†” ID: `{account_id}` ğŸ”’\n\n"
                    f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:*\n"
                    f"   `{status}`\n"
                    f"   {get_status_emoji(status)} {status_ar}\n\n"
                )

                if status.upper() in ["AVAILABLE", "ACTIVE", "LOGGED", "LOGGED IN"]:
                    result_text += f"ğŸ”„ *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©!*\n"
                    result_text += f"ğŸ”’ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù€ ID Ù…ÙØ¹Ù‘Ù„\n"
                elif status.upper() in ["WRONG DETAILS", "BACKUP CODE WRONG"]:
                    result_text += f"âš ï¸ *ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!*\n"

                available = format_number(account_info.get("Available", "0"))
                taken = format_number(account_info.get("Taken", "0"))

                if available != "0" or taken != "0":
                    result_text += f"\nğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {available}\nâœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {taken}"

                await msg.edit_text(result_text, parse_mode="Markdown")

        else:
            await msg.edit_text(
                f"âŒ *ÙØ´Ù„Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©*\nğŸ“§ `{data['email']}`\nâš ï¸ {message}",
                parse_mode="Markdown",
            )

    except Exception as e:
        logger.exception(f"âŒ Error: {data['email']}")
        await msg.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")


async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return

    if not context.args:
        await update.message.reply_text("ğŸ“ `/search email@example.com`", parse_mode="Markdown")
        return

    email = context.args[0].strip().lower()
    msg = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...")

    try:
        # Ø§Ù„Ø¨Ø­Ø« Ù…Ø¹ ØªÙØ±ÙŠØº Ø§Ù„Ù€ Cache Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø­Ø¯Ø« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        result = await api_manager.search_sender(email, force_refresh=True)

        if result:
            status = result.get("Status", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
            status_ar = get_status_description_ar(status)
            account_id = result.get("idAccount", "N/A")

            status_type = (
                "Ù†Ù‡Ø§Ø¦ÙŠØ© âœ…" if status in FINAL_STATUSES
                else ("Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ© â³" if status in TRANSITIONAL_STATUSES else "ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø© â“")
            )

            text = (
                f"âœ… *ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ±*\n\n"
                f"ğŸ“§ `{result.get('Sender', email)}`\n"
                f"ğŸ†” ID: `{account_id}` ğŸ”’\n"
                f"ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: {result.get('Group', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}\n\n"
                f"ğŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø©:* `{status}`\n"
                f"   {get_status_emoji(status)} {status_ar}\n"
                f"   ğŸ¯ Ø§Ù„Ù†ÙˆØ¹: {status_type}\n\n"
                f"ğŸ“… Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©: {format_number(result.get('Start', '0'))}\n"
                f"ğŸ• Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {result.get('Last Update', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}\n"
                f"ğŸ’° Ø§Ø³Ø­Ø¨: {format_number(result.get('Take', '0'))}\n"
                f"ğŸ’¸ ÙŠØ³ÙŠØ¨: {format_number(result.get('Keep', '0'))}\n"
                f"âœ… Ø§Ù„Ù…Ø³Ø­ÙˆØ¨: {format_number(result.get('Taken', '0'))}\n"
                f"ğŸ’µ Ø§Ù„Ù…ØªØ§Ø­: {format_number(result.get('Available', '0'))}"
            )

            accounts = load_monitored_accounts()
            if email in accounts:
                text += f"\n\nğŸ”„ *Ù…Ø±Ø§Ù‚Ø¨* (ID: `{accounts[email]['account_id']}`)"

            await msg.edit_text(text, parse_mode="Markdown")
        else:
            await msg.edit_text(f"âŒ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: `{email}`", parse_mode="Markdown")

    except Exception as e:
        await msg.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")


async def monitored(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return

    accounts = load_monitored_accounts()

    if not accounts:
        await update.message.reply_text("ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ø±Ø§Ù‚Ø¨Ø©")
        return

    text = f"ğŸ”„ *Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ({len(accounts)})*\n\n"

    for email, data in accounts.items():
        status = data["last_known_status"]
        status_ar = get_status_description_ar(status)

        text += (
            f"ğŸ“§ `{email}`\n"
            f"   ğŸ†” `{data['account_id']}` ğŸ”’\n"
            f"   ğŸ“Š *{status}*\n"
            f"   {get_status_emoji(status)} {status_ar}\n\n"
        )

    text += "âš¡ Mode: Enhanced Burst with ID Validation"

    await update.message.reply_text(text, parse_mode="Markdown")


async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return

    global stats

    reset_time = datetime.fromisoformat(stats.last_reset)
    hours = max((datetime.now() - reset_time).seconds / 3600, 0.01)
    requests_per_hour = stats.total_requests / hours

    text = (
        "ğŸ“Š *Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©*\n\n"
        f"ğŸ“ˆ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª: {stats.total_requests}\n"
        f"â±ï¸ Ø§Ù„Ù…Ø¹Ø¯Ù„: {requests_per_hour:.1f} Ø·Ù„Ø¨/Ø³Ø§Ø¹Ø©\n"
        f"ğŸš€ Ø·Ù„Ø¨Ø§Øª Burst: {stats.burst_requests}\n"
        f"âš¡ Ø§ÙƒØªØ´Ø§ÙØ§Øª Ø³Ø±ÙŠØ¹Ø©: {stats.fast_detections}\n"
        f"ğŸ”’ ØªØ­Ù‚Ù‚Ø§Øª Ø¨Ø§Ù„Ù€ ID: {stats.id_validations}\n"
        f"ğŸ›¡ï¸ ØªÙØ¹ÙŠÙ„Ø§Øª Fallback: {stats.fallback_activations}\n"
        f"ğŸ”„ CSRF refreshes: {stats.csrf_refreshes}\n"
        f"ğŸ“¦ Batch fetches: {stats.batch_fetches}\n"
        f"ğŸ¯ Cache hits: {stats.cache_hits}\n"
        f"âŒ Errors: {stats.errors}\n"
        f"ğŸ’¾ Cache rate: {(stats.cache_hits / max(stats.total_requests, 1) * 100):.1f}%\n\n"
        f"âš¡ Mode: Enhanced Hybrid\n"
        f"ğŸ• Ù…Ù†Ø°: {reset_time.strftime('%Y-%m-%d %H:%M:%S')}"
    )

    await update.message.reply_text(text, parse_mode="Markdown")


async def health_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    ğŸ“Š Ø¹Ø±Ø¶ ØµØ­Ø© Ø§Ù„Ù€ Cache (Ø¬Ø¯ÙŠØ¯!)
    """
    if not is_admin(update.effective_user.id):
        return

    global cache_health

    change_rate = cache_health.calculate_change_rate()
    
    last_fetch = "Never"
    if cache_health.last_successful_fetch:
        last_fetch_dt = datetime.fromisoformat(cache_health.last_successful_fetch)
        seconds_ago = (datetime.now() - last_fetch_dt).seconds
        last_fetch = f"{seconds_ago}s ago"

    health_status = "ğŸŸ¢ Excellent" if cache_health.consecutive_failures == 0 else (
        "ğŸŸ¡ Warning" if cache_health.consecutive_failures < 3 else "ğŸ”´ Critical"
    )

    text = (
        "ğŸ“Š *ØµØ­Ø© Ø§Ù„Ù€ Cache*\n\n"
        f"ğŸ¥ Ø§Ù„Ø­Ø§Ù„Ø©: {health_status}\n"
        f"ğŸ§  Adaptive TTL: {cache_health.adaptive_ttl}s\n"
        f"ğŸ“ˆ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª: {change_rate:.2f}/min\n"
        f"ğŸ“ Ø¢Ø®Ø± {len(cache_health.recent_changes)} ØªØºÙŠÙŠØ±Ø§Øª Ù…Ø³Ø¬Ù„Ø©\n"
        f"âŒ ÙØ´Ù„ Ù…ØªØªØ§Ù„ÙŠ: {cache_health.consecutive_failures}\n"
        f"âœ… Ø¢Ø®Ø± Ø¬Ù„Ø¨ Ù†Ø§Ø¬Ø­: {last_fetch}\n\n"
        f"*ğŸ¯ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© TTL:*\n"
        f"â€¢ >2 ØªØºÙŠÙŠØ±/Ø¯Ù‚ÙŠÙ‚Ø© â†’ {CACHE_TTL_MIN}s\n"
        f"â€¢ 0.5-2 ØªØºÙŠÙŠØ±/Ø¯Ù‚ÙŠÙ‚Ø© â†’ {CACHE_TTL_DEFAULT}s\n"
        f"â€¢ <0.5 ØªØºÙŠÙŠØ±/Ø¯Ù‚ÙŠÙ‚Ø© â†’ {CACHE_TTL_MAX}s"
    )

    await update.message.reply_text(text, parse_mode="Markdown")


async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return

    accounts = load_monitored_accounts()
    csrf_valid = (
        api_manager.csrf_expires_at and datetime.now() < api_manager.csrf_expires_at
    )

    burst_status = "ğŸ”¥ ACTIVE" if api_manager.burst_mode_active else "ğŸ’¤ Idle"
    if api_manager.burst_mode_active and api_manager.burst_mode_started:
        burst_elapsed = (datetime.now() - api_manager.burst_mode_started).seconds
        burst_remaining = max(0, BURST_MODE_DURATION - burst_elapsed)
        burst_status += f" ({burst_remaining}s left)"

    text = (
        "*ğŸ“Š Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù… - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©*\n\n"
        f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: âœ… Ø´ØºØ§Ù„\n"
        f"âš¡ Burst Mode: {burst_status}\n"
        f"ğŸ”‘ CSRF Token: {'âœ… ØµØ§Ù„Ø­' if csrf_valid else 'âš ï¸ Ù…Ù†ØªÙ‡ÙŠ'}\n"
        f"ğŸ’¾ Smart Cache: {'âœ… Ù†Ø´Ø·' if api_manager.cache_timestamp else 'âŒ ÙØ§Ø±Øº'}\n"
        f"ğŸ§  Adaptive TTL: {cache_health.adaptive_ttl}s\n"
        f"ğŸ”„ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©: {len(accounts)}\n\n"
        f"*âœ¨ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…ÙØ¹Ù‘Ù„Ø©:*\n"
        f"â€¢ ğŸ”’ Strict ID Validation: âœ…\n"
        f"â€¢ âš¡ Temporary Burst Mode: âœ…\n"
        f"â€¢ ğŸ§  Smart TTL Cache: âœ…\n"
        f"â€¢ ğŸ›¡ï¸ Fallback Mechanism: âœ…\n"
        f"â€¢ ğŸ“Š Change Detection: âœ…\n\n"
        f"*âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª:*\n"
        f"â€¢ Burst: 0-30s @ {BURST_MODE_INTERVAL}s\n"
        f"â€¢ Medium: 30-60s @ {MEDIUM_MODE_INTERVAL}s\n"
        f"â€¢ Normal: 60s+ @ {NORMAL_MODE_INTERVAL}s\n"
        f"â€¢ TTL Range: {CACHE_TTL_MIN}-{CACHE_TTL_MAX}s"
    )

    await update.message.reply_text(text, parse_mode="Markdown")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Main Function
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    global telegram_app

    print("\n" + "=" * 70)
    print("ğŸš€ SMART SENDER BOT - FINAL ENHANCED VERSION")
    print("=" * 70)
    print("\nâœ¨ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©:")
    print("   âœ… Strict ID Validation - Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù‡ÙˆÙŠØ©")
    print("   âš¡ Temporary Burst Mode - ÙˆØ¶Ø¹ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø¤Ù‚Øª (60s)")
    print("   ğŸ§  Smart TTL Cache - Ø°Ø§ÙƒØ±Ø© Ù…ØªÙƒÙŠÙØ© Ø°ÙƒÙŠØ© (2-10min)")
    print("   ğŸ›¡ï¸ Fallback Mechanism - Ø¢Ù„ÙŠØ© Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø©")
    print("   ğŸ“Š Change Detection & History")
    print("\nâš¡ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Burst:")
    print("   â€¢ 0-30s:  Real requests every 2-3s")
    print("   â€¢ 30-60s: Smart requests every 4-5s")
    print("   â€¢ 60s+:   Adaptive cache (2-10min TTL)")
    print("\nğŸ“Š Ø²Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹: 3-8 Ø«ÙˆØ§Ù†Ù")
    print("=" * 70 + "\n")

    telegram_app = Application.builder().token(CONFIG["telegram"]["bot_token"]).build()

    telegram_app.add_handler(CommandHandler("start", start))
    telegram_app.add_handler(CommandHandler("search", search))
    telegram_app.add_handler(CommandHandler("monitored", monitored))
    telegram_app.add_handler(CommandHandler("stats", stats_command))
    telegram_app.add_handler(CommandHandler("status", status_command))
    telegram_app.add_handler(CommandHandler("health", health_command))  # Ø¬Ø¯ÙŠØ¯!
    telegram_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    async def init_manager(_):
        await api_manager.initialize()
        asyncio.create_task(continuous_monitor())

    telegram_app.job_queue.run_once(init_manager, when=1)

    print("âœ… Bot is running with ALL enhancements!")
    print("ğŸ“Š Commands: /start /search /monitored /stats /status /health\n")

    telegram_app.run_polling(drop_pending_updates=True)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nâš ï¸ Bot stopped")
        stats.save()
        cache_health.save()
    except Exception as e:
        print(f"âŒ Error: {e}")
        logger.exception("âŒ Fatal error")
        stats.save()
        cache_health.save()
    finally:
        import asyncio
        asyncio.run(api_manager.close())
