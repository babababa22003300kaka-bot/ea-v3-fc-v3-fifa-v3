#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸš€ Smart Telegram Sender Bot - Adaptive Hybrid Monitoring
Bot: @snipe12_bot

Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:
- Smart Cache: Ø¬Ù„Ø¨ Ù…Ø±ÙƒØ²ÙŠ + Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø­Ù„ÙŠØ©
- Strict ID Validation: Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ù€ account_id
- Temporary Burst Mode: ØªØ­Ø¯ÙŠØ« Ø³Ø±ÙŠØ¹ (60 Ø«Ø§Ù†ÙŠØ©) Ù„Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
- Smart TTL: ÙØªØ±Ø© ØªØ­Ø¯ÙŠØ« Ù…ØªÙƒÙŠÙØ©
- Fallback Mechanism: Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
"""

import asyncio
import json
import logging
import random
import re
from dataclasses import asdict, dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

import aiohttp
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø³Ø¬Ù„Ø§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[
        logging.FileHandler("bot.log", encoding="utf-8"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

with open("config.json", "r", encoding="utf-8") as f:
    CONFIG = json.load(f)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CSRF_TOKEN_TTL = 1200

# Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ© ÙˆØ§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
TRANSITIONAL_STATUSES = {
    "LOGGING", "LOGGED", "LOGGED IN", "CODE SENT", "WAITING"
}

FINAL_STATUSES = {
    "AVAILABLE", "ACTIVE", "WRONG DETAILS", "BACKUP CODE WRONG",
    "NEW ACCOUNT", "DISABLED", "NO TRANSFER ACCESS", "TRANSFER LIST IS FULL",
    "NO CLUB", "GENERAL LOGIN ERROR", "ERROR", "BLOCKED", "AMOUNT TAKEN"
}

# Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù€ Cache Ø§Ù„Ø°ÙƒÙŠ
DEFAULT_CACHE_TTL = 300  # 5 Ø¯Ù‚Ø§Ø¦Ù‚
MIN_CACHE_TTL = 120      # Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ† (Ø¹Ù†Ø¯ Ù†Ø´Ø§Ø· Ù…Ø±ØªÙØ¹)
MAX_CACHE_TTL = 600      # 10 Ø¯Ù‚Ø§Ø¦Ù‚ (Ø¹Ù†Ø¯ Ù‡Ø¯ÙˆØ¡)
BURST_MODE_DURATION = 60 # Ù…Ø¯Ø© ÙˆØ¶Ø¹ Ø§Ù„Ù€ Burst (Ø«Ø§Ù†ÙŠØ©)
BURST_INTERVAL = (2, 3)  # ÙØªØ±Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ù€ Burst

# Ù…Ù„ÙØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
MONITORED_FILE = "monitored_accounts.json"
STATS_FILE = "stats.json"

telegram_app = None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class Stats:
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…"""
    total_requests: int = 0
    csrf_refreshes: int = 0
    batch_fetches: int = 0
    cache_hits: int = 0
    errors: int = 0
    changes_detected: int = 0
    burst_activations: int = 0
    fast_detections: int = 0
    fallback_uses: int = 0
    last_reset: str = datetime.now().isoformat()

    def save(self):
        try:
            with open(STATS_FILE, "w") as f:
                json.dump(asdict(self), f, indent=2)
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø£ Ø­ÙØ¸: {e}")

    @classmethod
    def load(cls):
        if Path(STATS_FILE).exists():
            try:
                with open(STATS_FILE, "r") as f:
                    return cls(**json.load(f))
            except:
                pass
        return cls()

stats = Stats.load()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ—„ï¸ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MonitorDB:
    """Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø¹ ID Validation"""
    
    def __init__(self):
        self.data = self._load()
    
    def _load(self) -> Dict:
        if Path(MONITORED_FILE).exists():
            try:
                with open(MONITORED_FILE, "r", encoding="utf-8") as f:
                    return json.load(f)
            except:
                pass
        return {}
    
    def _save(self):
        try:
            with open(MONITORED_FILE, "w", encoding="utf-8") as f:
                json.dump(self.data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø£ Ø­ÙØ¸: {e}")
    
    def add(self, email: str, account_id: str, status: str, chat_id: int):
        """Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ Ù…Ø¹ account_id Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚"""
        self.data[email.lower()] = {
            "account_id": account_id,  # âœ… Ø§Ù„Ù‡ÙˆÙŠØ© Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
            "status": status,
            "chat_id": chat_id,
            "added_at": datetime.now().isoformat(),
            "last_check": datetime.now().isoformat(),
            "check_count": 0
        }
        self._save()
        logger.info(f"âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© {email} (ID: {account_id})")
    
    def update_status(self, email: str, new_status: str):
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©"""
        email = email.lower()
        if email in self.data:
            self.data[email]["status"] = new_status
            self.data[email]["last_check"] = datetime.now().isoformat()
            self.data[email]["check_count"] += 1
            self._save()
    
    def get(self, email: str) -> Optional[Dict]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨"""
        return self.data.get(email.lower())
    
    def get_all(self) -> Dict:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙƒÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª"""
        return self.data.copy()
    
    def remove(self, email: str):
        """Ø­Ø°Ù Ø­Ø³Ø§Ø¨"""
        email = email.lower()
        if email in self.data:
            del self.data[email]
            self._save()

db = MonitorDB()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§  Smart Cache Manager
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SmartCacheManager:
    """
    Ù…Ø¯ÙŠØ± Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© Ø§Ù„Ø°ÙƒÙŠ
    - ÙØªØ±Ø© ØµÙ„Ø§Ø­ÙŠØ© Ù…ØªÙƒÙŠÙØ© (Smart TTL)
    - ÙˆØ¶Ø¹ Burst Ù„Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    - Ø¢Ù„ÙŠØ© Fallback
    """
    
    def __init__(self):
        self.cache: List[Dict] = []
        self.cache_timestamp: Optional[datetime] = None
        self.last_backup: List[Dict] = []  # Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
        
        # Smart TTL
        self.current_ttl = DEFAULT_CACHE_TTL
        self.last_changes_count = 0
        
        # Burst Mode Tracking
        self.burst_accounts: Dict[str, datetime] = {}  # email -> start_time
    
    def is_fresh(self) -> bool:
        """Ù‡Ù„ Ø§Ù„Ù€ Cache Ù„Ø§ ÙŠØ²Ø§Ù„ ØµØ§Ù„Ø­Ø§Ù‹ØŸ"""
        if not self.cache_timestamp:
            return False
        
        age = (datetime.now() - self.cache_timestamp).total_seconds()
        return age < self.current_ttl
    
    def should_burst_refresh(self) -> bool:
        """Ù‡Ù„ ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ Cache Ø¨Ø³Ø¨Ø¨ ÙˆØ¶Ø¹ BurstØŸ"""
        if not self.burst_accounts:
            return False
        
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù„ÙŠ Ø§Ù†ØªÙ‡Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ù€ Burst Ø¨ØªØ§Ø¹Ù‡Ø§
        current_time = datetime.now()
        expired = [
            email for email, start_time in self.burst_accounts.items()
            if (current_time - start_time).total_seconds() > BURST_MODE_DURATION
        ]
        
        for email in expired:
            del self.burst_accounts[email]
            logger.info(f"â±ï¸ Ø§Ù†ØªÙ‡Ù‰ Burst Mode Ù„Ù€ {email}")
        
        return len(self.burst_accounts) > 0
    
    def activate_burst(self, email: str):
        """ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Burst Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹ÙŠÙ†"""
        self.burst_accounts[email.lower()] = datetime.now()
        logger.info(f"ğŸš€ ØªÙØ¹ÙŠÙ„ Burst Mode Ù„Ù€ {email} ({BURST_MODE_DURATION}s)")
        
        global stats
        stats.burst_activations += 1
        stats.save()
    
    def update(self, accounts: List[Dict], changes_count: int = 0):
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ Cache"""
        self.cache = accounts
        self.cache_timestamp = datetime.now()
        
        # Ø­ÙØ¸ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
        if accounts:
            self.last_backup = accounts.copy()
        
        # ØªØ¹Ø¯ÙŠÙ„ TTL Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø´Ø§Ø·
        self._adjust_ttl(changes_count)
    
    def _adjust_ttl(self, changes_count: int):
        """
        ØªØ¹Ø¯ÙŠÙ„ ÙØªØ±Ø© Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
        - ØªØºÙŠÙŠØ±Ø§Øª ÙƒØ«ÙŠØ±Ø© â†’ TTL Ø£Ù‚ØµØ±
        - Ù‡Ø¯ÙˆØ¡ â†’ TTL Ø£Ø·ÙˆÙ„
        """
        if changes_count > 5:
            # Ù†Ø´Ø§Ø· Ù…Ø±ØªÙØ¹
            self.current_ttl = max(MIN_CACHE_TTL, self.current_ttl - 30)
            logger.info(f"ğŸ“‰ ØªÙ‚Ù„ÙŠÙ„ TTL Ø¥Ù„Ù‰ {self.current_ttl}s (Ù†Ø´Ø§Ø· Ù…Ø±ØªÙØ¹)")
        elif changes_count == 0 and self.last_changes_count == 0:
            # Ù‡Ø¯ÙˆØ¡ ØªØ§Ù…
            self.current_ttl = min(MAX_CACHE_TTL, self.current_ttl + 30)
            logger.info(f"ğŸ“ˆ Ø²ÙŠØ§Ø¯Ø© TTL Ø¥Ù„Ù‰ {self.current_ttl}s (Ù‡Ø¯ÙˆØ¡)")
        
        self.last_changes_count = changes_count
    
    def get(self) -> List[Dict]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ Cache (Ø£Ùˆ Fallback)"""
        if self.cache:
            return self.cache
        
        # Fallback: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¢Ø®Ø± Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
        if self.last_backup:
            logger.warning("âš ï¸ Ø§Ø³ØªØ®Ø¯Ø§Ù… Fallback Cache")
            global stats
            stats.fallback_uses += 1
            stats.save()
            return self.last_backup
        
        return []

cache_manager = SmartCacheManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸŒ Ù…Ø¯ÙŠØ± API Ø§Ù„Ù…Ø­Ø³Ù‘Ù†
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HybridAPIManager:
    """Ù…Ø¯ÙŠØ± API Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ù€ Cache Ø§Ù„Ù‡Ø¬ÙŠÙ†"""
    
    def __init__(self):
        self.base_url = CONFIG["website"]["urls"]["base"]
        self.cookies = CONFIG["website"]["cookies"]
        self.csrf_token = None
        self.csrf_expires_at = None
        self.session = None
    
    async def init(self):
        """ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù€ session"""
        if self.session is None or self.session.closed:
            connector = aiohttp.TCPConnector(limit=20, limit_per_host=10)
            timeout = aiohttp.ClientTimeout(total=30)
            self.session = aiohttp.ClientSession(
                connector=connector,
                timeout=timeout,
                cookies=self.cookies
            )
    
    async def get_csrf(self) -> Optional[str]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ CSRF token"""
        if self.csrf_token and self.csrf_expires_at:
            if datetime.now() < self.csrf_expires_at:
                return self.csrf_token
        
        await self.init()
        
        try:
            async with self.session.get(f"{self.base_url}/senderPage") as resp:
                if resp.status == 200:
                    html = await resp.text()
                    match = re.search(r'<meta name="csrf-token" content="([^"]+)"', html)
                    if match:
                        self.csrf_token = match.group(1)
                        self.csrf_expires_at = datetime.now() + timedelta(seconds=CSRF_TOKEN_TTL)
                        return self.csrf_token
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø£ CSRF: {e}")
        
        return None
    
    async def fetch_all_accounts(self) -> List[Dict]:
        """Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹"""
        global stats
        
        csrf = await self.get_csrf()
        if not csrf:
            return []
        
        await self.init()
        
        try:
            payload = {"date": "0", "bigUpdate": "0", "csrf_token": csrf}
            
            async with self.session.post(
                f"{self.base_url}/dataFunctions/updateSenderPage",
                data=payload
            ) as resp:
                
                stats.total_requests += 1
                stats.batch_fetches += 1
                
                if resp.status == 200:
                    data = await resp.json()
                    
                    if "data" in data:
                        accounts = data["data"]
                        
                        INDEX_MAP = {
                            "idAccount": 0, "image": 1, "Sender": 2,
                            "Start": 3, "Last Update": 4, "Taken": 5,
                            "Status": 6, "Available": 7, "password": 8,
                            "backupCodes": 9, "Group": 10, "groupNameId": 11,
                            "Take": 12, "Keep": 13
                        }
                        
                        parsed = []
                        for acc in accounts:
                            if len(acc) > 2:
                                account = {}
                                for key, idx in INDEX_MAP.items():
                                    account[key] = str(acc[idx]) if idx < len(acc) and acc[idx] else ""
                                parsed.append(account)
                        
                        logger.info(f"âœ… ØªÙ… Ø¬Ù„Ø¨ {len(parsed)} Ø­Ø³Ø§Ø¨")
                        return parsed
                
                elif resp.status in [403, 419]:
                    self.csrf_token = None
        
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø£ Ø¬Ù„Ø¨: {e}")
            stats.errors += 1
        
        return []
    
    async def search_in_cache(self, email: str, account_id: Optional[str] = None) -> Optional[Dict]:
        """
        Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù€ Cache Ø§Ù„Ù…Ø­Ù„ÙŠ Ù…Ø¹ ID Validation
        - Ø¥Ø°Ø§ ÙƒØ§Ù† account_id Ù…ÙˆØ¬ÙˆØ¯ØŒ Ù†ØªØ­Ù‚Ù‚ Ø¨ÙŠÙ‡ (Ø£ÙƒØ«Ø± Ø¯Ù‚Ø©)
        - Ø¥Ø°Ø§ Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯ØŒ Ù†Ø¨Ø­Ø« Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„
        """
        email = email.lower().strip()
        accounts = cache_manager.get()
        
        for acc in accounts:
            acc_email = acc.get("Sender", "").lower()
            acc_id = acc.get("idAccount", "")
            
            # âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ù„Ù€ ID (Ø¥Ø°Ø§ Ù…ØªÙˆÙØ±)
            if account_id:
                if acc_id == account_id and acc_email == email:
                    return acc
            else:
                # Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø¹Ø§Ø¯ÙŠ Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„
                if acc_email == email:
                    return acc
        
        return None
    
    async def add_sender(
        self, email: str, password: str, backup_codes: str = "",
        amount_take: str = "", amount_keep: str = ""
    ) -> Tuple[bool, str]:
        """Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨"""
        csrf = await self.get_csrf()
        if not csrf:
            return False, "No CSRF"
        
        await self.init()
        
        defaults = CONFIG["website"]["defaults"]
        payload = {
            "email": email,
            "password": password,
            "backupCodes": backup_codes,
            "groupName": defaults["group_name"],
            "accountLock": defaults["account_lock"],
            "amountToTake": amount_take or defaults.get("amount_take", ""),
            "amountToKeep": amount_keep or defaults.get("amount_keep", ""),
            "priority": defaults.get("priority", ""),
            "forceProxy": defaults.get("force_proxy", ""),
            "userPrice": defaults.get("user_price", ""),
            "csrf_token": csrf,
        }
        
        try:
            async with self.session.post(
                f"{self.base_url}/dataFunctions/addAccount",
                json=payload
            ) as resp:
                
                if resp.status == 200:
                    try:
                        data = await resp.json()
                        if "success" in data:
                            return True, data.get("success", "Success")
                        elif "error" in data:
                            error = data.get("error", "")
                            if "already" in error.lower():
                                return True, "Exists"
                            return False, error
                    except:
                        text = await resp.text()
                        if "success" in text.lower():
                            return True, "Success"
                        return False, text[:100]
                
                elif resp.status in [403, 419]:
                    self.csrf_token = None
                    return False, "CSRF expired"
                
                return False, f"Status {resp.status}"
        
        except Exception as e:
            return False, str(e)
    
    async def close(self):
        """Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù€ session"""
        if self.session and not self.session.closed:
            await self.session.close()

api_manager = HybridAPIManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ Ù…Ø­Ø¯Ù‘Ø« Ø§Ù„Ù€ Cache Ø§Ù„Ø°ÙƒÙŠ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def smart_cache_updater():
    """
    Ù…ÙØ­Ø¯Ù‘Ø« Ø§Ù„Ù€ Cache ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
    - ÙŠØ­Ø¯Ù‘Ø« Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø© (Smart TTL)
    - ÙŠØ¯Ø®Ù„ ÙˆØ¶Ø¹ Burst Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©
    - ÙŠØªØªØ¨Ø¹ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
    """
    logger.info("ğŸ”„ Ø¨Ø¯Ø¡ Ù…Ø­Ø¯Ù‘Ø« Ø§Ù„Ù€ Cache Ø§Ù„Ø°ÙƒÙŠ...")
    
    while True:
        try:
            should_update = False
            interval = cache_manager.current_ttl
            
            # ØªØ­Ù‚Ù‚: Ù‡Ù„ ÙÙŠ Ø­Ø³Ø§Ø¨Ø§Øª ÙÙŠ ÙˆØ¶Ø¹ BurstØŸ
            if cache_manager.should_burst_refresh():
                should_update = True
                interval = random.uniform(*BURST_INTERVAL)
                logger.info(f"ğŸš€ ØªØ­Ø¯ÙŠØ« Burst (ÙƒÙ„ {interval:.1f}s)")
            
            # ØªØ­Ù‚Ù‚: Ù‡Ù„ Ø§Ù„Ù€ Cache Ù‚Ø¯ÙŠÙ…ØŸ
            elif not cache_manager.is_fresh():
                should_update = True
                logger.info(f"ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø¹Ø§Ø¯ÙŠ (TTL={cache_manager.current_ttl}s)")
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ Cache
            if should_update:
                accounts = await api_manager.fetch_all_accounts()
                
                if accounts:
                    # Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
                    old_cache = cache_manager.get()
                    changes = detect_changes(old_cache, accounts)
                    
                    # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ Cache
                    cache_manager.update(accounts, changes_count=len(changes))
                    
                    # Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù„Ù„ØªØºÙŠÙŠØ±Ø§Øª
                    await notify_changes(changes)
                
                else:
                    logger.warning("âš ï¸ ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª - Ø§Ø³ØªØ®Ø¯Ø§Ù… Fallback")
            
            else:
                # Ø§Ù„Ù€ Cache Ù„Ø§ ÙŠØ²Ø§Ù„ ØµØ§Ù„Ø­
                global stats
                stats.cache_hits += 1
            
            await asyncio.sleep(interval)
        
        except Exception as e:
            logger.exception("âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø­Ø¯Ù‘Ø« Ø§Ù„Ù€ Cache")
            await asyncio.sleep(30)

def detect_changes(old: List[Dict], new: List[Dict]) -> List[Dict]:
    """ÙƒØ´Ù Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø¨ÙŠÙ† Ù†Ø³Ø®ØªÙŠÙ† Ù…Ù† Ø§Ù„Ù€ Cache"""
    changes = []
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ù„Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹
    old_map = {
        acc.get("idAccount"): acc
        for acc in old
        if acc.get("idAccount")
    }
    
    for new_acc in new:
        acc_id = new_acc.get("idAccount")
        if not acc_id:
            continue
        
        # Ù‡Ù„ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©ØŸ
        old_acc = old_map.get(acc_id)
        
        if old_acc:
            # ØªØ­Ù‚Ù‚ Ù…Ù† ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©
            old_status = old_acc.get("Status", "").upper()
            new_status = new_acc.get("Status", "").upper()
            
            if old_status != new_status:
                changes.append({
                    "account_id": acc_id,
                    "email": new_acc.get("Sender", ""),
                    "old_status": old_status,
                    "new_status": new_status,
                    "data": new_acc
                })
    
    if changes:
        logger.info(f"ğŸ”” ØªÙ… Ø§ÙƒØªØ´Ø§Ù {len(changes)} ØªØºÙŠÙŠØ±")
        
        global stats
        stats.changes_detected += len(changes)
        stats.save()
    
    return changes

async def notify_changes(changes: List[Dict]):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù„Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©"""
    for change in changes:
        email = change["email"].lower()
        account = db.get(email)
        
        if not account:
            continue
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù€ ID
        if account["account_id"] != change["account_id"]:
            logger.warning(f"âš ï¸ ID mismatch Ù„Ù€ {email}")
            continue
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©
        db.update_status(email, change["new_status"])
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±
        await send_status_notification(
            email,
            change["account_id"],
            change["old_status"],
            change["new_status"],
            account["chat_id"],
            change["data"]
        )

async def send_status_notification(
    email: str, account_id: str, old_status: str,
    new_status: str, chat_id: int, account_data: Dict
):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©"""
    try:
        old_emoji = get_status_emoji(old_status)
        new_emoji = get_status_emoji(new_status)
        old_desc = get_status_description_ar(old_status)
        new_desc = get_status_description_ar(new_status)
        
        notification = (
            f"ğŸ”” *ØªÙ†Ø¨ÙŠÙ‡ ØªØºÙŠÙŠØ±!*\n\n"
            f"ğŸ“§ `{email}`\n"
            f"ğŸ†” ID: `{account_id}`\n\n"
            f"ğŸ“Š *Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©:* `{old_status}`\n"
            f"   {old_emoji} {old_desc}\n\n"
            f"ğŸ“Š *Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:* `{new_status}`\n"
            f"   {new_emoji} {new_desc}\n\n"
            f"ğŸ• {datetime.now().strftime('%H:%M:%S')}\n"
        )
        
        available = format_number(account_data.get("Available", "0"))
        taken = format_number(account_data.get("Taken", "0"))
        
        if available != "0" or taken != "0":
            notification += f"\nğŸ’µ Ù…ØªØ§Ø­: {available}\nâœ… Ù…Ø³Ø­ÙˆØ¨: {taken}"
        
        await telegram_app.bot.send_message(
            chat_id=chat_id,
            text=notification,
            parse_mode="Markdown"
        )
        
    except Exception as e:
        logger.error(f"âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (Burst Mode)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def monitor_new_account(email: str, message_obj, chat_id: int) -> Tuple[bool, Optional[Dict]]:
    """
    Ù…Ø±Ø§Ù‚Ø¨Ø© Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Burst Mode
    - ÙŠÙØ¹Ù‘Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø±ÙŠØ¹ (2-3 Ø«ÙˆØ§Ù†ÙŠ) Ù„Ù…Ø¯Ø© 60 Ø«Ø§Ù†ÙŠØ©
    - ÙŠØ³ØªØ®Ø¯Ù… ID Validation
    - ÙŠÙƒØªØ´Ù Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø¨Ø³Ø±Ø¹Ø©
    """
    
    logger.info(f"ğŸš€ Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨Ø© {email} (Burst Mode)")
    
    # ØªÙØ¹ÙŠÙ„ Burst Mode ÙÙŠ Ø§Ù„Ù€ Cache Manager
    cache_manager.activate_burst(email)
    
    # Ø¥Ø¬Ø¨Ø§Ø± ØªØ­Ø¯ÙŠØ« ÙÙˆØ±ÙŠ
    accounts = await api_manager.fetch_all_accounts()
    if accounts:
        cache_manager.update(accounts)
    
    start_time = datetime.now()
    last_status = None
    account_id = None
    stable_count = 0
    max_attempts = 30
    
    for attempt in range(1, max_attempts + 1):
        try:
            # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù€ Cache (Ù…Ø¹ ID Ø¥Ø°Ø§ Ù…ØªÙˆÙØ±)
            account = await api_manager.search_in_cache(email, account_id)
            
            if not account:
                await message_obj.edit_text(
                    f"ğŸ” *Ø¨Ø­Ø«...*\n\n"
                    f"ğŸ“§ `{email}`\n"
                    f"â±ï¸ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{max_attempts}",
                    parse_mode="Markdown"
                )
                
                await asyncio.sleep(2)
                continue
            
            # Ø­ÙØ¸ Ø§Ù„Ù€ ID Ø¹Ù†Ø¯ Ø£ÙˆÙ„ Ø§ÙƒØªØ´Ø§Ù
            if not account_id:
                account_id = account.get("idAccount", "")
                logger.info(f"âœ… ØªÙ… Ø§ÙƒØªØ´Ø§Ù ID: {account_id}")
            
            status = account.get("Status", "").upper()
            
            # ØªØªØ¨Ø¹ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
            if status != last_status:
                elapsed = (datetime.now() - start_time).total_seconds()
                logger.info(f"ğŸ“Š {email} â†’ {status} ({elapsed:.1f}s)")
                
                last_status = status
                stable_count = 0
            else:
                stable_count += 1
            
            # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø­Ø§Ù„Ø©
            is_final = status in FINAL_STATUSES
            status_desc = get_status_description_ar(status)
            
            await message_obj.edit_text(
                f"ğŸš€ *Ù…Ø±Ø§Ù‚Ø¨Ø© Ø³Ø±ÙŠØ¹Ø©*\n\n"
                f"ğŸ“§ `{email}`\n"
                f"ğŸ†” ID: `{account_id}`\n\n"
                f"ğŸ“Š `{status}`\n"
                f"   {get_status_emoji(status)} {status_desc}\n\n"
                f"ğŸ¯ {'Ù†Ù‡Ø§Ø¦ÙŠØ© âœ…' if is_final else 'Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ© â³'}\n"
                f"â±ï¸ {int((datetime.now() - start_time).total_seconds())}s",
                parse_mode="Markdown"
            )
            
            # Ø´Ø±ÙˆØ· Ø§Ù„ØªÙˆÙ‚Ù
            if is_final and stable_count >= 2:
                # Ø­Ø§Ù„Ø© Ù†Ù‡Ø§Ø¦ÙŠØ© ÙˆÙ…Ø³ØªÙ‚Ø±Ø©
                logger.info(f"âœ… {email} Ù…Ø³ØªÙ‚Ø± Ø¹Ù†Ø¯ {status}")
                
                # Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ù…Ø¹ ID
                db.add(email, account_id, status, chat_id)
                
                global stats
                stats.fast_detections += 1
                stats.save()
                
                return True, account
            
            # Ø§Ù†ØªØ¸Ø§Ø± Ù‚ØµÙŠØ±
            await asyncio.sleep(random.uniform(2, 3))
        
        except Exception as e:
            logger.exception(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©: {e}")
            await asyncio.sleep(2)
    
    # Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª
    logger.warning(f"â±ï¸ {email}: timeout")
    
    if account_id and last_status:
        db.add(email, account_id, last_status, chat_id)
        return True, account
    
    return False, None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def format_number(value) -> str:
    if not value or value == "null":
        return "0"
    try:
        num = float(str(value))
        if abs(num) < 1000:
            return str(int(num))
        return f"{int(num/1000)}k"
    except:
        return str(value)

def get_status_emoji(status: str) -> str:
    emojis = {
        "LOGGING": "ğŸ”„", "LOGGED": "âœ…", "ACTIVE": "âœ…",
        "AVAILABLE": "ğŸ’°", "CODE SENT": "ğŸ“§", "AMOUNT TAKEN": "ğŸ’¸",
        "WRONG DETAILS": "âš ï¸", "DISABLED": "ğŸ”’", "WAITING": "â³",
        "BLOCKED": "ğŸš«", "ERROR": "âŒ", "BACKUP CODE WRONG": "ğŸ”‘",
        "TRANSFER LIST IS FULL": "ğŸ“¦"
    }
    return emojis.get(status.upper(), "ğŸ“Š")

def get_status_description_ar(status: str) -> str:
    descriptions = {
        "LOGGING": "Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        "LOGGED": "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        "ACTIVE": "Ù†Ø´Ø·",
        "AVAILABLE": "Ù…ØªØ§Ø­ - Ø¬Ø§Ù‡Ø²",
        "CODE SENT": "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯",
        "AMOUNT TAKEN": "ØªÙ… Ø§Ù„Ø³Ø­Ø¨",
        "WRONG DETAILS": "Ø¨ÙŠØ§Ù†Ø§Øª Ø®Ø§Ø·Ø¦Ø©",
        "DISABLED": "Ù…Ø¹Ø·Ù„",
        "NO TRANSFER ACCESS": "Ø§Ù„Ù…Ø§Ø±ÙƒØª Ù…Ù‚ÙÙˆÙ„",
        "BACKUP CODE WRONG": "Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ ØºÙ„Ø·",
        "TRANSFER LIST IS FULL": "Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù…Ù„ÙŠØ§Ù†Ø©",
        "WAITING": "Ù…Ù†ØªØ¸Ø±",
        "BLOCKED": "Ù…Ø­Ø¸ÙˆØ±",
        "ERROR": "Ø®Ø·Ø£"
    }
    return descriptions.get(status.upper(), status)

def parse_sender_data(text: str) -> Dict:
    lines = text.strip().split("\n")
    data = {"email": "", "password": "", "codes": [], "amount_take": "", "amount_keep": ""}
    email_pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if re.match(email_pattern, line):
            data["email"] = line.lower()
        elif "Ø§Ø³Ø­Ø¨" in line:
            match = re.search(r"Ø§Ø³Ø­Ø¨\s*(\d+)", line)
            if match:
                data["amount_take"] = match.group(1)
        elif "ÙŠØ³ÙŠØ¨" in line:
            match = re.search(r"ÙŠØ³ÙŠØ¨\s*(\d+)", line)
            if match:
                data["amount_keep"] = match.group(1)
        elif re.match(r"^[\d.]+$", line):
            clean_code = line.split(".")[-1] if "." in line else line
            data["codes"].append(clean_code)
        elif data["email"] and not data["password"]:
            data["password"] = line
    
    data["codes"] = ",".join(data["codes"])
    return data

def is_admin(user_id: int) -> bool:
    admin_ids = CONFIG["telegram"].get("admin_ids", [])
    return not admin_ids or user_id in admin_ids

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø£Ù…Ø± /start"""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("âŒ ØºÙŠØ± Ù…ØµØ±Ù‘Ø­")
        return
    
    welcome = (
        f"Ù…Ø±Ø­Ø¨Ø§Ù‹ {update.effective_user.first_name}! ğŸ‘‹\n\n"
        "ğŸ§  *Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù‡Ø¬ÙŠÙ† Ø§Ù„Ø°ÙƒÙŠ*\n\n"
        "âœ¨ *Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©:*\n"
        "â€¢ ğŸ§  Smart Cache: Ø¬Ù„Ø¨ Ù…Ø±ÙƒØ²ÙŠ + Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø­Ù„ÙŠØ©\n"
        "â€¢ ğŸ” ID Validation: ØªØ­Ù‚Ù‚ Ø¯Ù‚ÙŠÙ‚ Ø¨Ø§Ù„Ù€ account_id\n"
        "â€¢ ğŸš€ Burst Mode: ØªØ­Ø¯ÙŠØ« Ø³Ø±ÙŠØ¹ (60s) Ù„Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©\n"
        "â€¢ ğŸ“Š Smart TTL: ÙØªØ±Ø© ØªØ­Ø¯ÙŠØ« Ù…ØªÙƒÙŠÙØ©\n"
        "â€¢ ğŸ›¡ï¸ Fallback: Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„\n\n"
        "*ğŸ“ Ø§Ù„Ø£ÙˆØ§Ù…Ø±:*\n"
        "Ø§Ø¨Ø¹Øª Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ù„Ø¥Ø¶Ø§ÙØ©\n"
        "`/list` - Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©\n"
        "`/stats` - Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª\n"
        "`/check email` - ÙØ­Øµ ÙÙˆØ±ÙŠ"
    )
    
    await update.message.reply_text(welcome, parse_mode="Markdown")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨"""
    
    if not is_admin(update.effective_user.id):
        return
    
    if update.message.text.startswith("/"):
        return
    
    data = parse_sender_data(update.message.text)
    
    if not data["email"] or not data["password"]:
        await update.message.reply_text("âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©!")
        return
    
    msg = await update.message.reply_text(
        f"â³ *Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø¶Ø§ÙØ©...*\nğŸ“§ `{data['email']}`",
        parse_mode="Markdown"
    )
    
    try:
        # Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…ÙˆÙ‚Ø¹
        success, message = await api_manager.add_sender(
            email=data["email"],
            password=data["password"],
            backup_codes=data["codes"],
            amount_take=data["amount_take"],
            amount_keep=data["amount_keep"],
        )
        
        if not success:
            await msg.edit_text(f"âŒ ÙØ´Ù„: {message}", parse_mode="Markdown")
            return
        
        await msg.edit_text(
            f"âœ… *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©!*\n\n"
            f"ğŸš€ *ØªÙØ¹ÙŠÙ„ Burst Mode...*\n"
            f"â±ï¸ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø³Ø±ÙŠØ¹Ø© (60 Ø«Ø§Ù†ÙŠØ©)",
            parse_mode="Markdown"
        )
        
        # Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø¹ Burst Mode
        success, account = await monitor_new_account(
            data["email"],
            msg,
            update.effective_chat.id
        )
        
        if account:
            status = account.get("Status", "")
            
            result = (
                f"âœ… *Ø§ÙƒØªÙ…Ù„!*\n\n"
                f"ğŸ“§ `{data['email']}`\n"
                f"ğŸ†” ID: `{account.get('idAccount')}`\n\n"
                f"ğŸ“Š `{status}`\n"
                f"   {get_status_emoji(status)} {get_status_description_ar(status)}\n\n"
            )
            
            if status in FINAL_STATUSES:
                result += "âœ… *ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©!*\n"
            
            available = format_number(account.get("Available", "0"))
            taken = format_number(account.get("Taken", "0"))
            
            if available != "0" or taken != "0":
                result += f"\nğŸ’µ Ù…ØªØ§Ø­: {available}\nâœ… Ù…Ø³Ø­ÙˆØ¨: {taken}"
            
            await msg.edit_text(result, parse_mode="Markdown")
    
    except Exception as e:
        logger.exception(f"âŒ Ø®Ø·Ø£: {e}")
        await msg.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def list_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¹Ø±Ø¶ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª"""
    
    if not is_admin(update.effective_user.id):
        return
    
    accounts = db.get_all()
    
    if not accounts:
        await update.message.reply_text("ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª")
        return
    
    text = f"ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ({len(accounts)})*\n\n"
    
    for email, data in accounts.items():
        status = data["status"]
        text += (
            f"ğŸ“§ `{email}`\n"
            f"   ğŸ†” `{data['account_id']}`\n"
            f"   ğŸ“Š {get_status_emoji(status)} {status}\n\n"
        )
    
    text += f"ğŸ§  Smart Cache | TTL: {cache_manager.current_ttl}s"
    
    await update.message.reply_text(text, parse_mode="Markdown")

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
    
    if not is_admin(update.effective_user.id):
        return
    
    uptime = (datetime.now() - datetime.fromisoformat(stats.last_reset)).seconds
    
    text = (
        "ğŸ“Š *Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª*\n\n"
        f"ğŸ“ˆ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª: {stats.total_requests}\n"
        f"ğŸ¯ Cache hits: {stats.cache_hits}\n"
        f"ğŸ“¦ Batch fetches: {stats.batch_fetches}\n"
        f"ğŸ”” ØªØºÙŠÙŠØ±Ø§Øª Ù…ÙƒØªØ´ÙØ©: {stats.changes_detected}\n"
        f"ğŸš€ ØªÙØ¹ÙŠÙ„Ø§Øª Burst: {stats.burst_activations}\n"
        f"âš¡ Ø§ÙƒØªØ´Ø§ÙØ§Øª Ø³Ø±ÙŠØ¹Ø©: {stats.fast_detections}\n"
        f"ğŸ›¡ï¸ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Øª Fallback: {stats.fallback_uses}\n"
        f"âŒ Ø£Ø®Ø·Ø§Ø¡: {stats.errors}\n\n"
        f"ğŸ§  Smart TTL: {cache_manager.current_ttl}s\n"
        f"â±ï¸ ÙˆÙ‚Øª Ø§Ù„ØªØ´ØºÙŠÙ„: {uptime//3600}h {(uptime%3600)//60}m"
    )
    
    await update.message.reply_text(text, parse_mode="Markdown")

async def check_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙØ­Øµ ÙÙˆØ±ÙŠ"""
    
    if not is_admin(update.effective_user.id):
        return
    
    if not context.args:
        await update.message.reply_text("ğŸ“ `/check email@example.com`", parse_mode="Markdown")
        return
    
    email = context.args[0].strip().lower()
    account = db.get(email)
    
    # Ø§Ù„Ø¨Ø­Ø« Ù…Ø¹ ID Ø¥Ø°Ø§ Ù…ØªÙˆÙØ±
    account_id = account["account_id"] if account else None
    
    result = await api_manager.search_in_cache(email, account_id)
    
    if result:
        status = result.get("Status", "")
        
        text = (
            f"âœ… *Ù†ØªÙŠØ¬Ø© Ø§Ù„ÙØ­Øµ*\n\n"
            f"ğŸ“§ `{email}`\n"
            f"ğŸ†” ID: `{result.get('idAccount')}`\n\n"
            f"ğŸ“Š `{status}`\n"
            f"   {get_status_emoji(status)} {get_status_description_ar(status)}\n\n"
            f"ğŸ’µ Ù…ØªØ§Ø­: {format_number(result.get('Available', '0'))}\n"
            f"âœ… Ù…Ø³Ø­ÙˆØ¨: {format_number(result.get('Taken', '0'))}"
        )
        
        await update.message.reply_text(text, parse_mode="Markdown")
    else:
        await update.message.reply_text(f"âŒ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: `{email}`", parse_mode="Markdown")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def post_init(application: Application):
    """Ø§Ù„ØªÙ‡ÙŠØ¦Ø©"""
    global telegram_app
    telegram_app = application
    
    await api_manager.init()
    
    # Ø¨Ø¯Ø¡ Ù…Ø­Ø¯Ù‘Ø« Ø§Ù„Ù€ Cache
    asyncio.create_task(smart_cache_updater())
    
    logger.info("âœ… Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø²!")

def main():
    """Ø§Ù„ØªØ´ØºÙŠÙ„"""
    
    print("\n" + "=" * 70)
    print("ğŸ§  ADAPTIVE HYBRID MONITORING SYSTEM")
    print("=" * 70)
    print("âœ¨ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©:")
    print("   â€¢ ğŸ§  Smart Cache: Ø¬Ù„Ø¨ Ù…Ø±ÙƒØ²ÙŠ + Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø­Ù„ÙŠØ©")
    print("   â€¢ ğŸ” Strict ID Validation: ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ù€ account_id")
    print("   â€¢ ğŸš€ Temporary Burst Mode: ØªØ­Ø¯ÙŠØ« Ø³Ø±ÙŠØ¹ (60s)")
    print("   â€¢ ğŸ“Š Smart TTL: 2-10 Ø¯Ù‚Ø§Ø¦Ù‚ (Ù…ØªÙƒÙŠÙ)")
    print("   â€¢ ğŸ›¡ï¸ Fallback Mechanism: Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ©")
    print("\nğŸ”¥ Ø£Ø°ÙƒÙ‰ ÙˆØ£Ø³Ø±Ø¹ Ù†Ø¸Ø§Ù… Ù…Ø±Ø§Ù‚Ø¨Ø©!")
    print("=" * 70 + "\n")
    
    app = Application.builder().token(
        CONFIG["telegram"]["bot_token"]
    ).post_init(post_init).build()
    
    app.add_handler(CommandHandler("start", start_command))
    app.add_handler(CommandHandler("list", list_command))
    app.add_handler(CommandHandler("stats", stats_command))
    app.add_handler(CommandHandler("check", check_command))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    
    print("âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„!")
    print("ğŸ§  Smart Cache Ù†Ø´Ø·")
    print("âš¡ Burst Mode Ø¬Ø§Ù‡Ø² Ù„Ù„ØªÙØ¹ÙŠÙ„\n")
    
    app.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nâš ï¸ Ø¥ÙŠÙ‚Ø§Ù...")
        stats.save()
    except Exception as e:
        logger.exception("âŒ Ø®Ø·Ø£ ÙØ§Ø¯Ø­")
        stats.save()
